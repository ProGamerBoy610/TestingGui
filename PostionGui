-- LUNA UI
local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/master/source.lua", true))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Window = Luna:CreateWindow({
	Name = "Fryzer Hub",
	Subtitle = "Join Discord",
	LogoID = "",
	LoadingEnabled = true,
	LoadingTitle = "Loading...",
	LoadingSubtitle = "May take few minutes",

	ConfigSettings = {
		RootFolder = nil,
		ConfigFolder = "Fryzer Hub"
	},

	KeySystem = false,
	KeySettings = {
		Title = "Luna Example Key",
		Subtitle = "Key System",
		Note = "Best Key System Ever! Also, Please Use A HWID Keysystem like Pelican, Luarmor etc. that provide key strings based on your HWID since putting a simple string is very easy to bypass, the key is 1234!",
		SaveInRoot = false,
		SaveKey = true,
		Key = {"1234"},
		SecondAction = {
			Enabled = true,
			Type = "Link",
			Parameter = ""
		}
	}
})

-- ESP & Aimbot Variables
local ESPObjects = {}
local wallCheckESPObjects = {}
local targetPlayer = nil
local aimbotEnabled = false
local silentAimEnabled = false
local espEnabled = false
local espWallCheckEnabled = false
local espTracerEnabled = false
local aimPart = "Head"
local smoothness = 0.4
local wallCheck = true
local smoothAim = false
local silentAimRange = 999

-- Walkspeed Variables
local walkSpeedEnabled = false
local walkSpeedValue = 16
local originalWalkSpeed = 16

-- Auto Respawn Variables
local autoRespawnEnabled = false
local playerDead = false

-- ESP Tracer Variables
local tracerLines = {}

-- Silent Aim Setup
local bulletHandler = nil

local function initSilentAim()
	pcall(function()
		bulletHandler = require(game:GetService("ReplicatedStorage").ModuleScripts.GunModules.BulletHandler)
		
		if bulletHandler then
			local oldFire = bulletHandler.Fire
			bulletHandler.Fire = function(data)
				if silentAimEnabled then
					local closest = getClosestTargetForSilentAim(silentAimRange)
					if closest then
						data.Force = data.Force * 1000
						data.Direction = (closest.Position - data.Origin).Unit
					end
				end
				return oldFire(data)
			end
		end
	end)
end

function getClosestTargetForSilentAim(range)
	local closestPart, closestDistance = nil, range
	
	for _, player in pairs(Players:GetPlayers()) do
		if player == LocalPlayer then continue end
		
		local character = player.Character
		if not character then continue end
		
		local humanoid = character:FindFirstChild("Humanoid")
		local head = character:FindFirstChild("Head")
		
		if not head or not humanoid or humanoid.Health == 0 then continue end
		
		local screenPosition, onScreen = Camera:WorldToViewportPoint(head.Position)
		if not onScreen then continue end
		
		local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - Camera.ViewportSize / 2).Magnitude
		
		if distance < closestDistance then
			closestPart = head
			closestDistance = distance
		end
	end
	
	return closestPart
end

Window:CreateHomeTab({
	SupportedExecutors = {
		"Synapse X", "Krnl", "ProtoSmasher", "Fluxus", "Script-Ware",
		"EasyExploits", "Electron", "JJSploit", "Calamari", "SirHurt",
		"Sentinel", "WEAREDEVS", "Comet", "Cellery", "Wave", "CODex", "Delta"
	},
	DiscordInvite = "https://discord.gg/UKYHGddQD3",
	Icon = 1
})

-- Combat Tab
local CombatTab = Window:CreateTab({
	Name = "Combat",
	Icon = "gps_fixed",
	ImageSource = "Material",
	ShowTitle = true
})

-- Player Tab
local PlayerTab = Window:CreateTab({
	Name = "Player",
	Icon = "person",
	ImageSource = "Material",
	ShowTitle = true
})

-- Aimbot Functions
local function raycastCheck(origin, target)
	if not wallCheck then return true end
	
	local ray = Ray.new(origin, (target - origin).Unit * 1000)
	local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character})
	
	if hit and targetPlayer and hit:IsDescendantOf(targetPlayer.Character) then
		return true
	end
	return false
end

local function checkLineOfSight(from, to, player)
	local ray = Ray.new(from, (to - from).Unit * 1000)
	local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character})
	
	if hit and player.Character and hit:IsDescendantOf(player.Character) then
		return true
	end
	return false
end

local function getClosestPlayer()
	local closest = nil
	local shortestDistance = math.huge
	
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local humanoid = player.Character:FindFirstChild("Humanoid")
			local targetPartNode = player.Character:FindFirstChild(aimPart)
			
			if humanoid and humanoid.Health > 0 and targetPartNode then
				local screenPos, onScreen = Camera:WorldToViewportPoint(targetPartNode.Position)
				
				if onScreen then
					local distance = (Vector2.new(screenPos.X, screenPos.Y) - Camera.ViewportSize / 2).Magnitude
					
					if distance < shortestDistance then
						if raycastCheck(Camera.CFrame.Position, targetPartNode.Position) then
							closest = player
							shortestDistance = distance
						end
					end
				end
			end
		end
	end
	
	return closest
end

local function aimbot()
	if not aimbotEnabled then 
		return 
	end
	
	local target = getClosestPlayer()
	
	if target and target.Character then
		local targetPart = target.Character:FindFirstChild(aimPart)
		if targetPart then
			targetPlayer = target
			local aimPosition = targetPart.Position
			local cameraPosition = Camera.CFrame.Position
			local direction = (aimPosition - cameraPosition).Unit
			
			if smoothAim then
				local targetCFrame = CFrame.new(cameraPosition, cameraPosition + direction)
				Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, smoothness)
			else
				Camera.CFrame = CFrame.new(cameraPosition, cameraPosition + direction)
			end
		end
	else
		targetPlayer = nil
	end
end

-- ESP Functions
local function createESP(Player)
	if ESPObjects[Player] or Player == LocalPlayer then return end
	
	local ESPHolder = {
		Box = Drawing.new("Square"),
		Outline = Drawing.new("Square"),
		Name = Drawing.new("Text"),
		Distance = Drawing.new("Text"),
		Health = Drawing.new("Text")
	}
	
	ESPHolder.Box.Thickness = 2
	ESPHolder.Box.Filled = false
	ESPHolder.Box.Color = Color3.fromRGB(255, 0, 0)
	ESPHolder.Box.Visible = false
	ESPHolder.Box.ZIndex = 2
	ESPHolder.Box.Transparency = 1
	
	ESPHolder.Outline.Thickness = 4
	ESPHolder.Outline.Filled = false
	ESPHolder.Outline.Color = Color3.fromRGB(0, 0, 0)
	ESPHolder.Outline.Visible = false
	ESPHolder.Outline.ZIndex = 1
	ESPHolder.Outline.Transparency = 0.8
	
	ESPHolder.Name.Size = 16
	ESPHolder.Name.Center = true
	ESPHolder.Name.Outline = true
	ESPHolder.Name.Font = 3
	ESPHolder.Name.Color = Color3.fromRGB(255, 255, 255)
	ESPHolder.Name.Visible = false
	
	ESPHolder.Distance.Size = 13
	ESPHolder.Distance.Center = true
	ESPHolder.Distance.Outline = true
	ESPHolder.Distance.Font = 2
	ESPHolder.Distance.Color = Color3.fromRGB(200, 200, 255)
	ESPHolder.Distance.Visible = false
	
	ESPHolder.Health.Size = 13
	ESPHolder.Health.Center = true
	ESPHolder.Health.Outline = true
	ESPHolder.Health.Font = 2
	ESPHolder.Health.Color = Color3.fromRGB(0, 255, 0)
	ESPHolder.Health.Visible = false
	
	ESPObjects[Player] = ESPHolder
end

local function createWallCheckESP(Player)
	if wallCheckESPObjects[Player] or Player == LocalPlayer then return end
	
	local ESPHolder = {
		Box = Drawing.new("Square"),
		Outline = Drawing.new("Square"),
		Name = Drawing.new("Text"),
		Distance = Drawing.new("Text"),
		Health = Drawing.new("Text"),
		WallStatus = Drawing.new("Text")
	}
	
	ESPHolder.Box.Thickness = 2
	ESPHolder.Box.Filled = false
	ESPHolder.Box.Color = Color3.fromRGB(255, 0, 0)
	ESPHolder.Box.Visible = false
	ESPHolder.Box.ZIndex = 2
	ESPHolder.Box.Transparency = 1
	
	ESPHolder.Outline.Thickness = 4
	ESPHolder.Outline.Filled = false
	ESPHolder.Outline.Color = Color3.fromRGB(0, 0, 0)
	ESPHolder.Outline.Visible = false
	ESPHolder.Outline.ZIndex = 1
	ESPHolder.Outline.Transparency = 0.8
	
	ESPHolder.Name.Size = 16
	ESPHolder.Name.Center = true
	ESPHolder.Name.Outline = true
	ESPHolder.Name.Font = 3
	ESPHolder.Name.Color = Color3.fromRGB(255, 255, 255)
	ESPHolder.Name.Visible = false
	
	ESPHolder.Distance.Size = 13
	ESPHolder.Distance.Center = true
	ESPHolder.Distance.Outline = true
	ESPHolder.Distance.Font = 2
	ESPHolder.Distance.Color = Color3.fromRGB(200, 200, 255)
	ESPHolder.Distance.Visible = false
	
	ESPHolder.Health.Size = 13
	ESPHolder.Health.Center = true
	ESPHolder.Health.Outline = true
	ESPHolder.Health.Font = 2
	ESPHolder.Health.Color = Color3.fromRGB(0, 255, 0)
	ESPHolder.Health.Visible = false
	
	ESPHolder.WallStatus.Size = 12
	ESPHolder.WallStatus.Center = true
	ESPHolder.WallStatus.Outline = true
	ESPHolder.WallStatus.Font = 2
	ESPHolder.WallStatus.Color = Color3.fromRGB(0, 255, 0)
	ESPHolder.WallStatus.Visible = false
	
	wallCheckESPObjects[Player] = ESPHolder
end

local function removeESP(Player)
	if ESPObjects[Player] then
		for _, drawing in pairs(ESPObjects[Player]) do
			drawing:Remove()
		end
		ESPObjects[Player] = nil
	end
end

local function removeWallCheckESP(Player)
	if wallCheckESPObjects[Player] then
		for _, drawing in pairs(wallCheckESPObjects[Player]) do
			drawing:Remove()
		end
		wallCheckESPObjects[Player] = nil
	end
end

local function updateESP()
	for Player, ESP in pairs(ESPObjects) do
		pcall(function()
			if Player and Player.Character and Player ~= LocalPlayer then
				local Character = Player.Character
				local Humanoid = Character:FindFirstChildOfClass("Humanoid")
				local RootPart = Character:FindFirstChild("HumanoidRootPart")
				local Head = Character:FindFirstChild("Head")
				
				if Humanoid and RootPart and Head and Humanoid.Health > 0 and LocalPlayer.Character then
					local Distance = (LocalPlayer.Character.HumanoidRootPart.Position - RootPart.Position).Magnitude
					
					if Distance > 5000 then
						ESP.Box.Visible = false
						ESP.Name.Visible = false
						ESP.Distance.Visible = false
						ESP.Health.Visible = false
						return
					end
					
					local Vector, OnScreen = Camera:WorldToViewportPoint(RootPart.Position)
					
					if OnScreen and espEnabled then
						local HeadPos = Camera:WorldToViewportPoint(Head.Position + Vector3.new(0, 0.5, 0))
						local LegPos = Camera:WorldToViewportPoint(RootPart.Position - Vector3.new(0, 3, 0))
						
						local Height = math.abs(HeadPos.Y - LegPos.Y)
						local Width = Height / 2
						
						ESP.Box.Size = Vector2.new(Width, Height)
						ESP.Box.Position = Vector2.new(Vector.X - Width / 2, Vector.Y - Height / 2)
						ESP.Box.Color = (targetPlayer == Player) and Color3.fromRGB(0, 255, 100) or Color3.fromRGB(255, 0, 0)
						ESP.Box.Visible = true
						
						ESP.Outline.Size = Vector2.new(Width, Height)
						ESP.Outline.Position = Vector2.new(Vector.X - Width / 2, Vector.Y - Height / 2)
						ESP.Outline.Visible = true
						
						ESP.Name.Text = Player.Name
						ESP.Name.Position = Vector2.new(Vector.X, HeadPos.Y - 25)
						ESP.Name.Visible = true
						
						local HealthPercent = math.floor((Humanoid.Health / Humanoid.MaxHealth) * 100)
						ESP.Health.Text = HealthPercent .. "â¤"
						ESP.Health.Position = Vector2.new(Vector.X, LegPos.Y + 20)
						
						if HealthPercent > 75 then
							ESP.Health.Color = Color3.fromRGB(0, 255, 100)
						elseif HealthPercent > 50 then
							ESP.Health.Color = Color3.fromRGB(255, 255, 0)
						elseif HealthPercent > 25 then
							ESP.Health.Color = Color3.fromRGB(255, 150, 0)
						else
							ESP.Health.Color = Color3.fromRGB(255, 0, 0)
						end
						ESP.Health.Visible = true
						
						ESP.Distance.Text = math.floor(Distance) .. "m"
						ESP.Distance.Position = Vector2.new(Vector.X, LegPos.Y + 5)
						ESP.Distance.Visible = true
					else
						ESP.Box.Visible = false
						ESP.Name.Visible = false
						ESP.Distance.Visible = false
						ESP.Health.Visible = false
						ESP.Outline.Visible = false
					end
				end
			end
		end)
	end
end

local function updateWallCheckESP()
	for Player, ESP in pairs(wallCheckESPObjects) do
		pcall(function()
			if Player and Player.Character and Player ~= LocalPlayer then
				local Character = Player.Character
				local Humanoid = Character:FindFirstChildOfClass("Humanoid")
				local RootPart = Character:FindFirstChild("HumanoidRootPart")
				local Head = Character:FindFirstChild("Head")
				
				if Humanoid and RootPart and Head and Humanoid.Health > 0 and LocalPlayer.Character then
					local Distance = (LocalPlayer.Character.HumanoidRootPart.Position - RootPart.Position).Magnitude
					
					if Distance > 5000 then
						ESP.Box.Visible = false
						ESP.Name.Visible = false
						ESP.Distance.Visible = false
						ESP.Health.Visible = false
						ESP.WallStatus.Visible = false
						return
					end
					
					local Vector, OnScreen = Camera:WorldToViewportPoint(RootPart.Position)
					
					if OnScreen and espWallCheckEnabled then
						local HeadPos = Camera:WorldToViewportPoint(Head.Position + Vector3.new(0, 0.5, 0))
						local LegPos = Camera:WorldToViewportPoint(RootPart.Position - Vector3.new(0, 3, 0))
						
						local Height = math.abs(HeadPos.Y - LegPos.Y)
						local Width = Height / 2
						
						-- Check line of sight
						local canSee = checkLineOfSight(Camera.CFrame.Position, Head.Position, Player)
						local boxColor = canSee and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
						
						ESP.Box.Size = Vector2.new(Width, Height)
						ESP.Box.Position = Vector2.new(Vector.X - Width / 2, Vector.Y - Height / 2)
						ESP.Box.Color = boxColor
						ESP.Box.Visible = true
						
						ESP.Outline.Size = Vector2.new(Width, Height)
						ESP.Outline.Position = Vector2.new(Vector.X - Width / 2, Vector.Y - Height / 2)
						ESP.Outline.Visible = true
						
						ESP.Name.Text = Player.Name
						ESP.Name.Position = Vector2.new(Vector.X, HeadPos.Y - 25)
						ESP.Name.Color = boxColor
						ESP.Name.Visible = true
						
						local HealthPercent = math.floor((Humanoid.Health / Humanoid.MaxHealth) * 100)
						ESP.Health.Text = HealthPercent .. "â¤"
						ESP.Health.Position = Vector2.new(Vector.X, LegPos.Y + 20)
						
						if HealthPercent > 75 then
							ESP.Health.Color = Color3.fromRGB(0, 255, 100)
						elseif HealthPercent > 50 then
							ESP.Health.Color = Color3.fromRGB(255, 255, 0)
						elseif HealthPercent > 25 then
							ESP.Health.Color = Color3.fromRGB(255, 150, 0)
						else
							ESP.Health.Color = Color3.fromRGB(255, 0, 0)
						end
						ESP.Health.Visible = true
						
						ESP.Distance.Text = math.floor(Distance) .. "m"
						ESP.Distance.Position = Vector2.new(Vector.X, LegPos.Y + 5)
						ESP.Distance.Visible = true
						
						ESP.WallStatus.Text = canSee and "âœ“ VISIBLE" or "âœ— WALL"
						ESP.WallStatus.Color = canSee and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
						ESP.WallStatus.Position = Vector2.new(Vector.X, LegPos.Y + 35)
						ESP.WallStatus.Visible = true
					else
						ESP.Box.Visible = false
						ESP.Name.Visible = false
						ESP.Distance.Visible = false
						ESP.Health.Visible = false
						ESP.WallStatus.Visible = false
						ESP.Outline.Visible = false
					end
				end
			end
		end)
	end
end

-- ESP Tracer Functions
local function createTracerLine(player)
	if tracerLines[player] then return end
	
	local line = Drawing.new("Line")
	line.Thickness = 2
	line.Transparency = 0.8
	line.Visible = false
	
	tracerLines[player] = line
end

local function removeTracerLine(player)
	if tracerLines[player] then
		tracerLines[player]:Remove()
		tracerLines[player] = nil
	end
end

local function updateTracers()
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local character = player.Character
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local head = character:FindFirstChild("Head")
			
			if humanoid and humanoid.Health > 0 and head and tracerLines[player] then
				local tracer = tracerLines[player]
				local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
				
				if onScreen and espTracerEnabled then
					local canSee = checkLineOfSight(Camera.CFrame.Position, head.Position, player)
					
					-- Green if visible, Red if behind wall
					tracer.Color = canSee and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
					tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
					tracer.To = Vector2.new(screenPos.X, screenPos.Y)
					tracer.Visible = true
				else
					tracer.Visible = false
				end
			end
		end
	end
end

-- Walkspeed Function
local function updateWalkSpeed()
	if walkSpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
		LocalPlayer.Character.Humanoid.WalkSpeed = walkSpeedValue
	end
end

-- Auto Respawn Function
local function checkAutoRespawn()
	if not autoRespawnEnabled then return end
	
	if LocalPlayer.Character then
		local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		
		if humanoid and humanoid.Health <= 0 then
			if not playerDead then
				playerDead = true
				
				-- Fire spawn event twice immediately for faster respawn
				pcall(function()
					local Spawned = ReplicatedStorage.SignalManager.SignalEvents.Spawned
					Spawned:Fire()
					Spawned:Fire()
				end)
			end
		else
			playerDead = false
		end
	end
end

local Button = CombatTab:CreateButton({
	Name = "Player Tracker!",
	Description = "Track players with an advanced raycasting system.",
    	Callback = function()
         local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "UltraESP"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = player:WaitForChild("PlayerGui")

-- Main Frame (Glass effect - auto-expanding)
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 180, 0, 50) -- Will auto-expand
MainFrame.Position = UDim2.new(1, -200, 0.3, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(5, 5, 15)
MainFrame.BackgroundTransparency = 0.6
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.ClipsDescendants = false
MainFrame.Parent = ScreenGui

-- Multiple glass layers for depth
local GlassLayer1 = Instance.new("Frame")
GlassLayer1.Size = UDim2.new(1, 0, 1, 0)
GlassLayer1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
GlassLayer1.BackgroundTransparency = 0.95
GlassLayer1.BorderSizePixel = 0
GlassLayer1.ZIndex = 0
GlassLayer1.Parent = MainFrame

local GlassCorner1 = Instance.new("UICorner")
GlassCorner1.CornerRadius = UDim.new(0, 10)
GlassCorner1.Parent = GlassLayer1

-- Outer glow border
local OuterStroke = Instance.new("UIStroke")
OuterStroke.Color = Color3.fromRGB(150, 200, 255)
OuterStroke.Thickness = 2
OuterStroke.Transparency = 0.4
OuterStroke.Parent = MainFrame

-- Inner border for glass effect
local InnerStroke = Instance.new("UIStroke")
InnerStroke.Color = Color3.fromRGB(255, 255, 255)
InnerStroke.Thickness = 1
InnerStroke.Transparency = 0.7
InnerStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
InnerStroke.Parent = GlassLayer1

-- Rounded corners
local MainCorner = Instance.new("UICorner")
MainCorner.CornerRadius = UDim.new(0, 10)
MainCorner.Parent = MainFrame

-- Gradient for depth
local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 150, 200))
})
UIGradient.Transparency = NumberSequence.new({
    NumberSequenceKeypoint.new(0, 0.95),
    NumberSequenceKeypoint.new(1, 0.98)
})
UIGradient.Rotation = 45
UIGradient.Parent = GlassLayer1

-- Top Bar (minimal)
local TopBar = Instance.new("Frame")
TopBar.Name = "TopBar"
TopBar.Size = UDim2.new(1, 0, 0, 25)
TopBar.BackgroundColor3 = Color3.fromRGB(10, 10, 25)
TopBar.BackgroundTransparency = 0.4
TopBar.BorderSizePixel = 0
TopBar.Parent = MainFrame

local TopCorner = Instance.new("UICorner")
TopCorner.CornerRadius = UDim.new(0, 10)
TopCorner.Parent = TopBar

local TopCoverBottom = Instance.new("Frame")
TopCoverBottom.Size = UDim2.new(1, 0, 0, 8)
TopCoverBottom.Position = UDim2.new(0, 0, 1, -8)
TopCoverBottom.BackgroundColor3 = Color3.fromRGB(10, 10, 25)
TopCoverBottom.BackgroundTransparency = 0.4
TopCoverBottom.BorderSizePixel = 0
TopCoverBottom.Parent = TopBar

-- Title with glow
local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Size = UDim2.new(1, -35, 1, 0)
Title.Position = UDim2.new(0, 6, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "Player Tracker"
Title.TextColor3 = Color3.fromRGB(200, 230, 255)
Title.TextSize = 11
Title.Font = Enum.Font.GothamBold
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.TextStrokeTransparency = 0.8
Title.Parent = TopBar

-- Close Button
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Size = UDim2.new(0, 20, 0, 20)
CloseButton.Position = UDim2.new(1, -23, 0, 2.5)
CloseButton.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
CloseButton.BackgroundTransparency = 0.5
CloseButton.BorderSizePixel = 0
CloseButton.Text = "Ã—"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 14
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Parent = TopBar

local CloseCorner = Instance.new("UICorner")
CloseCorner.CornerRadius = UDim.new(0, 5)
CloseCorner.Parent = CloseButton

local CloseStroke = Instance.new("UIStroke")
CloseStroke.Color = Color3.fromRGB(255, 255, 255)
CloseStroke.Thickness = 1
CloseStroke.Transparency = 0.7
CloseStroke.Parent = CloseButton

-- Container for player entries (auto-expanding)
local PlayerContainer = Instance.new("Frame")
PlayerContainer.Name = "PlayerContainer"
PlayerContainer.Size = UDim2.new(1, -8, 1, -30)
PlayerContainer.Position = UDim2.new(0, 4, 0, 28)
PlayerContainer.BackgroundTransparency = 1
PlayerContainer.BorderSizePixel = 0
PlayerContainer.Parent = MainFrame

local ListLayout = Instance.new("UIListLayout")
ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
ListLayout.Padding = UDim.new(0, 3)
ListLayout.Parent = PlayerContainer

-- Auto-resize frame based on content
ListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    local contentHeight = ListLayout.AbsoluteContentSize.Y
    MainFrame.Size = UDim2.new(0, 180, 0, contentHeight + 35)
end)

-- Dragging functionality
local dragging = false
local dragStart = nil
local startPos = nil

TopBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
    end
end)

TopBar.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

-- Close button
CloseButton.MouseButton1Click:Connect(function()
    ScreenGui:Destroy()
end)

CloseButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        ScreenGui:Destroy()
    end
end)

-- RaycastParams for wall check
local rayParams = RaycastParams.new()
rayParams.FilterType = Enum.RaycastFilterType.Exclude
rayParams.IgnoreWater = true

-- Function to check if player is visible
local function isPlayerVisible(targetPosition)
    local character = player.Character
    if not character then return false end
    
    local head = character:FindFirstChild("Head")
    if not head then return false end
    
    local direction = (targetPosition - head.Position).Unit
    local distance = (targetPosition - head.Position).Magnitude
    
    rayParams.FilterDescendantsInstances = {character}
    
    local rayResult = workspace:Raycast(head.Position, direction * distance, rayParams)
    
    if rayResult then
        local hitPlayer = Players:GetPlayerFromCharacter(rayResult.Instance.Parent)
        return hitPlayer ~= nil
    end
    
    return true
end

-- Function to get rotation angle for arrow
local function getDirectionRotation(targetPosition)
    local character = player.Character
    if not character then return 0 end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return 0 end
    
    local directionToTarget = (targetPosition - hrp.Position).Unit
    local lookVector = hrp.CFrame.LookVector
    
    -- Calculate angle in degrees
    local angle = math.atan2(directionToTarget.X, directionToTarget.Z) - math.atan2(lookVector.X, lookVector.Z)
    local degrees = math.deg(angle)
    
    return degrees
end

-- Player frames storage
local playerFrames = {}

-- Function to create player entry
local function createPlayerEntry(targetPlayer)
    local PlayerFrame = Instance.new("Frame")
    PlayerFrame.Name = targetPlayer.Name
    PlayerFrame.Size = UDim2.new(1, 0, 0, 20)
    PlayerFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 30)
    PlayerFrame.BackgroundTransparency = 0.7
    PlayerFrame.BorderSizePixel = 0
    PlayerFrame.Parent = PlayerContainer
    
    local FrameCorner = Instance.new("UICorner")
    FrameCorner.CornerRadius = UDim.new(0, 5)
    FrameCorner.Parent = PlayerFrame
    
    local FrameStroke = Instance.new("UIStroke")
    FrameStroke.Color = Color3.fromRGB(255, 255, 255)
    FrameStroke.Thickness = 0.5
    FrameStroke.Transparency = 0.8
    FrameStroke.Parent = PlayerFrame
    
    -- Arrow indicator (rotating)
    local Arrow = Instance.new("TextLabel")
    Arrow.Name = "Arrow"
    Arrow.Size = UDim2.new(0, 15, 1, 0)
    Arrow.Position = UDim2.new(0, 2, 0, 0)
    Arrow.BackgroundTransparency = 1
    Arrow.Text = "â¬†"
    Arrow.TextColor3 = Color3.fromRGB(255, 255, 255)
    Arrow.TextSize = 11
    Arrow.Font = Enum.Font.GothamBold
    Arrow.TextXAlignment = Enum.TextXAlignment.Center
    Arrow.Rotation = 0
    Arrow.Parent = PlayerFrame
    
    -- Player info: Name | Distance
    local InfoLabel = Instance.new("TextLabel")
    InfoLabel.Name = "InfoLabel"
    InfoLabel.Size = UDim2.new(1, -20, 1, 0)
    InfoLabel.Position = UDim2.new(0, 18, 0, 0)
    InfoLabel.BackgroundTransparency = 1
    InfoLabel.Text = targetPlayer.Name .. " | --"
    InfoLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    InfoLabel.TextSize = 9
    InfoLabel.Font = Enum.Font.Gotham
    InfoLabel.TextXAlignment = Enum.TextXAlignment.Left
    InfoLabel.TextTruncate = Enum.TextTruncate.AtEnd
    InfoLabel.TextStrokeTransparency = 0.9
    InfoLabel.Parent = PlayerFrame
    
    playerFrames[targetPlayer] = {
        Frame = PlayerFrame,
        Label = InfoLabel,
        Arrow = Arrow
    }
end

-- Function to format distance
local function formatDistance(distance)
    if distance < 1000 then
        return string.format("%.0fm", distance)
    else
        return string.format("%.1fk", distance / 1000)
    end
end

-- Function to update player info
local function updatePlayerInfo()
    local character = player.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    for _, targetPlayer in pairs(Players:GetPlayers()) do
        if targetPlayer ~= player then
            if not playerFrames[targetPlayer] then
                createPlayerEntry(targetPlayer)
            end
            
            local targetChar = targetPlayer.Character
            if targetChar then
                local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
                
                if targetHRP then
                    local frame = playerFrames[targetPlayer]
                    
                    -- Calculate distance
                    local distance = (hrp.Position - targetHRP.Position).Magnitude
                    local distText = formatDistance(distance)
                    
                    -- Get direction rotation and update arrow
                    local rotation = getDirectionRotation(targetHRP.Position)
                    frame.Arrow.Rotation = rotation
                    
                    -- Wall check
                    local isVisible = isPlayerVisible(targetHRP.Position)
                    
                    -- Update label
                    frame.Label.Text = targetPlayer.Name .. " | " .. distText
                    
                    -- Color based on visibility with glow
                    if isVisible then
                        frame.Label.TextColor3 = Color3.fromRGB(120, 255, 120)
                        frame.Arrow.TextColor3 = Color3.fromRGB(120, 255, 120)
                        frame.Frame.BackgroundColor3 = Color3.fromRGB(15, 30, 15)
                        frame.Frame.BackgroundTransparency = 0.6
                    else
                        frame.Label.TextColor3 = Color3.fromRGB(255, 120, 120)
                        frame.Arrow.TextColor3 = Color3.fromRGB(255, 120, 120)
                        frame.Frame.BackgroundColor3 = Color3.fromRGB(30, 15, 15)
                        frame.Frame.BackgroundTransparency = 0.6
                    end
                end
            end
        end
    end
end

-- Handle player leaving
Players.PlayerRemoving:Connect(function(removedPlayer)
    if playerFrames[removedPlayer] then
        playerFrames[removedPlayer].Frame:Destroy()
        playerFrames[removedPlayer] = nil
    end
end)

-- Update loop
RunService.Heartbeat:Connect(function()
    updatePlayerInfo()
end)

-- Initialize existing players
for _, targetPlayer in pairs(Players:GetPlayers()) do
    if targetPlayer ~= player then
        createPlayerEntry(targetPlayer)
    end
end

-- Handle new players joining
Players.PlayerAdded:Connect(function(newPlayer)
    if newPlayer ~= player then
        createPlayerEntry(newPlayer)
    end
end)

print("===================")
print("Ultra Glass ESP Loaded!")
print("===================")
print("âœ“ Rotating arrow (â¬†)")
print("âœ“ Auto-expanding")
print("âœ“ Green = Visible")
print("âœ“ Red = Behind wall")
print("===================")
    	end
})

-- Combat Tab - Silent Aim Section
local SilentAimSection = CombatTab:CreateSection("Silent Aim")

local SilentAimToggle = CombatTab:CreateToggle({
	Name = "Enable Silent Aim",
	CurrentValue = false,
	Flag = "SilentAimToggle",
	Callback = function(Value)
		silentAimEnabled = Value
		if Value then
			initSilentAim()
		end
	end,
})

silentAimRange = 9999 -- Max distance for silent aim

local WallCheckToggle = CombatTab:CreateToggle({
	Name = "Wall Check (Aimbot)",
	CurrentValue = true,
	Flag = "WallCheckToggle",
	Callback = function(Value)
		wallCheck = Value
	end,
})

-- Combat Tab - Standard ESP Section
local ESPSection = CombatTab:CreateSection("Standard ESP")

-- Store connections OUTSIDE the callback so they persist
local basicEspConnections = {}

local Toggle = CombatTab:CreateToggle({
	Name = "Player ESP",
	Description = nil,
	CurrentValue = false,
	Callback = function(Value)
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		local player = Players.LocalPlayer
		
		-- ESP Settings
		local teamCheck = true
		local espColor = Color3.fromRGB(255, 0, 0)
		local espColorTeam = Color3.fromRGB(0, 255, 0)
		
		-- Function to create ESP highlight
		local function createESP(character)
			if character:FindFirstChild("ESPHighlight") then return end
			
			local highlight = Instance.new("Highlight")
			highlight.Name = "ESPHighlight"
			highlight.FillTransparency = 0.5
			highlight.OutlineTransparency = 0
			highlight.OutlineColor = espColor
			highlight.FillColor = espColor
			highlight.Adornee = character
			highlight.Parent = character
		end
		
		-- Function to remove ESP
		local function removeESP(character)
			local highlight = character:FindFirstChild("ESPHighlight")
			if highlight then
				highlight:Destroy()
			end
		end
		
		-- Function to update ESP color based on team
		local function updateESP(targetPlayer)
			if not targetPlayer.Character then return end
			
			local highlight = targetPlayer.Character:FindFirstChild("ESPHighlight")
			if not highlight then return end
			
			-- Team check
			if teamCheck and targetPlayer.Team == player.Team then
				highlight.FillColor = espColorTeam
				highlight.OutlineColor = espColorTeam
			else
				highlight.FillColor = espColor
				highlight.OutlineColor = espColor
			end
		end
		
		-- Function to remove all ESP
		local function removeAllESP()
			for _, targetPlayer in pairs(Players:GetPlayers()) do
				if targetPlayer.Character then
					removeESP(targetPlayer.Character)
				end
			end
		end
		
		if Value then
			-- ESP is enabled
			print("===================")
			print("ESP Loaded!")
			print("===================")
			print("Red = Enemy")
			print("Green = Teammate")
			print("===================")
			
			-- Apply ESP to existing players
			for _, targetPlayer in pairs(Players:GetPlayers()) do
				if targetPlayer ~= player then
					if targetPlayer.Character then
						createESP(targetPlayer.Character)
						updateESP(targetPlayer)
					end
					
					-- Character added connection
					local charConn = targetPlayer.CharacterAdded:Connect(function(character)
						wait(0.5)
						createESP(character)
						updateESP(targetPlayer)
					end)
					table.insert(basicEspConnections, charConn)
				end
			end
			
			-- Player added connection
			local playerAddedConn = Players.PlayerAdded:Connect(function(targetPlayer)
				local charConn = targetPlayer.CharacterAdded:Connect(function(character)
					wait(0.5)
					if targetPlayer ~= player then
						createESP(character)
						updateESP(targetPlayer)
					end
				end)
				table.insert(basicEspConnections, charConn)
			end)
			table.insert(basicEspConnections, playerAddedConn)
			
			-- Update ESP colors continuously
			local heartbeatConn = RunService.Heartbeat:Connect(function()
				for _, targetPlayer in pairs(Players:GetPlayers()) do
					if targetPlayer ~= player then
						updateESP(targetPlayer)
					end
				end
			end)
			table.insert(basicEspConnections, heartbeatConn)
			
			-- Player leaving connection
			local playerRemovingConn = Players.PlayerRemoving:Connect(function(targetPlayer)
				if targetPlayer.Character then
					removeESP(targetPlayer.Character)
				end
			end)
			table.insert(basicEspConnections, playerRemovingConn)
			
		else
			-- ESP is disabled - cleanup
			print("===================")
			print("ESP Disabled!")
			print("===================")
			
			-- Disconnect all connections
			for _, conn in pairs(basicEspConnections) do
				conn:Disconnect()
			end
			basicEspConnections = {} -- Clear the table
			
			-- Remove all ESP highlights
			removeAllESP()
		end
	end
})

local ESPToggle = CombatTab:CreateToggle({
	Name = "Shows Name, Distance, Health",
	CurrentValue = false,
	Flag = "ESPToggle",
	Callback = function(Value)
		espEnabled = Value
		
		if Value then
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer then
					createESP(player)
				end
			end
			
			RunService:BindToRenderStep("UpdateESP", Enum.RenderPriority.Camera.Value + 1, updateESP)
		else
			RunService:UnbindFromRenderStep("UpdateESP")
			
			for player, _ in pairs(ESPObjects) do
				removeESP(player)
			end
		end
	end,
})

-- Combat Tab - ESP with Wall Check Section
local WallCheckESPSection = CombatTab:CreateSection("ESP (Wall Check)")

-- Store connections OUTSIDE the callback so they persist
local espConnections = {}

local Toggle = CombatTab:CreateToggle({
	Name = "Player ESP Wall Check",
	Description = nil,
	CurrentValue = false,
	Callback = function(Value)
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		local player = Players.LocalPlayer
		
		-- ESP Colors
		local colorVisible = Color3.fromRGB(0, 255, 0) -- Green = Can see
		local colorHidden = Color3.fromRGB(255, 0, 0) -- Red = Behind wall
		
		-- RaycastParams for wall check
		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Exclude
		rayParams.IgnoreWater = true
		
		-- Function to check if player is visible (wall check)
		local function isPlayerVisible(targetCharacter)
			local character = player.Character
			if not character then return false end
			
			local head = character:FindFirstChild("Head")
			if not head then return false end
			
			local targetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
			if not targetHRP then return false end
			
			local direction = (targetHRP.Position - head.Position).Unit
			local distance = (targetHRP.Position - head.Position).Magnitude
			
			rayParams.FilterDescendantsInstances = {character, targetCharacter}
			
			local rayResult = workspace:Raycast(head.Position, direction * distance, rayParams)
			
			if rayResult then
				-- If we hit something, there's a wall
				return false
			end
			
			-- No obstruction
			return true
		end
		
		-- Function to create ESP highlight
		local function createESP(character)
			if character:FindFirstChild("ESPHighlight") then return end
			
			local highlight = Instance.new("Highlight")
			highlight.Name = "ESPHighlight"
			highlight.FillTransparency = 0.5
			highlight.OutlineTransparency = 0
			highlight.OutlineColor = colorHidden
			highlight.FillColor = colorHidden
			highlight.Adornee = character
			highlight.Parent = character
		end
		
		-- Function to remove ESP
		local function removeESP(character)
			local highlight = character:FindFirstChild("ESPHighlight")
			if highlight then
				highlight:Destroy()
			end
		end
		
		-- Function to update ESP color based on wall check
		local function updateESP(targetPlayer)
			if not targetPlayer.Character then return end
			
			local highlight = targetPlayer.Character:FindFirstChild("ESPHighlight")
			if not highlight then return end
			
			-- Wall check
			local isVisible = isPlayerVisible(targetPlayer.Character)
			
			if isVisible then
				-- Green = Can see (no walls)
				highlight.FillColor = colorVisible
				highlight.OutlineColor = colorVisible
			else
				-- Red = Behind wall
				highlight.FillColor = colorHidden
				highlight.OutlineColor = colorHidden
			end
		end
		
		-- Function to remove all ESP
		local function removeAllESP()
			for _, targetPlayer in pairs(Players:GetPlayers()) do
				if targetPlayer.Character then
					removeESP(targetPlayer.Character)
				end
			end
		end
		
		if Value then
			-- ESP is enabled
			print("===================")
			print("ESP with Wall Check Loaded!")
			print("===================")
			print("ðŸŸ¢ Green = Visible (no walls)")
			print("ðŸ”´ Red = Behind wall")
			print("===================")
			
			-- Apply ESP to existing players
			for _, targetPlayer in pairs(Players:GetPlayers()) do
				if targetPlayer ~= player then
					if targetPlayer.Character then
						createESP(targetPlayer.Character)
						updateESP(targetPlayer)
					end
					
					-- Character added connection
					local charConn = targetPlayer.CharacterAdded:Connect(function(character)
						wait(0.5)
						createESP(character)
						updateESP(targetPlayer)
					end)
					table.insert(espConnections, charConn)
				end
			end
			
			-- Player added connection
			local playerAddedConn = Players.PlayerAdded:Connect(function(targetPlayer)
				local charConn = targetPlayer.CharacterAdded:Connect(function(character)
					wait(0.5)
					if targetPlayer ~= player then
						createESP(character)
						updateESP(targetPlayer)
					end
				end)
				table.insert(espConnections, charConn)
			end)
			table.insert(espConnections, playerAddedConn)
			
			-- Update ESP colors continuously (wall check)
			local heartbeatConn = RunService.Heartbeat:Connect(function()
				for _, targetPlayer in pairs(Players:GetPlayers()) do
					if targetPlayer ~= player then
						updateESP(targetPlayer)
					end
				end
			end)
			table.insert(espConnections, heartbeatConn)
			
			-- Player leaving connection
			local playerRemovingConn = Players.PlayerRemoving:Connect(function(targetPlayer)
				if targetPlayer.Character then
					removeESP(targetPlayer.Character)
				end
			end)
			table.insert(espConnections, playerRemovingConn)
			
		else
			-- ESP is disabled - cleanup
			print("===================")
			print("ESP Disabled!")
			print("===================")
			
			-- Disconnect all connections
			for _, conn in pairs(espConnections) do
				conn:Disconnect()
			end
			espConnections = {} -- Clear the table
			
			-- Remove all ESP highlights
			removeAllESP()
		end
	end
})
-- Combat Tab - ESP Tracer Section
local TracerSection = CombatTab:CreateSection("ESP Tracer (Wall Check)")

local TracerToggle = CombatTab:CreateToggle({
	Name = "Enable Tracer",
	CurrentValue = false,
	Flag = "TracerToggle",
	Callback = function(Value)
		espTracerEnabled = Value
		
		if Value then
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer then
					createTracerLine(player)
				end
			end
			
			RunService:BindToRenderStep("UpdateTracers", Enum.RenderPriority.Camera.Value + 1, updateTracers)
		else
			RunService:UnbindFromRenderStep("UpdateTracers")
			
			for player, _ in pairs(tracerLines) do
				removeTracerLine(player)
			end
		end
	end,
})

-- Player Tab - Walkspeed Section
local WalkSpeedSection = PlayerTab:CreateSection("Walkspeed")

local WalkSpeedToggle = PlayerTab:CreateToggle({
	Name = "Enable Walkspeed",
	CurrentValue = false,
	Flag = "WalkSpeedToggle",
	Callback = function(Value)
		walkSpeedEnabled = Value
		if not Value and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
			LocalPlayer.Character.Humanoid.WalkSpeed = originalWalkSpeed
		end
	end,
})

local WalkSpeedSlider = PlayerTab:CreateSlider({
	Name = "Walkspeed Value",
	Range = {16, 200},
	Increment = 5,
	CurrentValue = 16,
	Flag = "WalkSpeedSlider",
	Callback = function(Value)
		walkSpeedValue = Value
	end,
})

-- Player Tab - Auto Respawn Section
local AutoRespawnSection = PlayerTab:CreateSection("Auto Respawn")

local AutoRespawnToggle = PlayerTab:CreateToggle({
	Name = "Enable Auto Respawn",
	CurrentValue = false,
	Flag = "AutoRespawnToggle",
	Callback = function(Value)
		autoRespawnEnabled = Value
		playerDead = false
	end,
})


Luna:Notification({
	Title = "Fryzer Hub Loaded",
	Content = "Script loaded with all features!",
	Icon = "check_circle",
	ImageSource = "Material"
})
