-- Explicitly declare the Tabs table to avoid scope issues
local Tabs = {}

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Player = LocalPlayer
local PlayerName = Player.DisplayName  -- Define PlayerName explicitly
local AccountAge = Player.AccountAge
local GameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")

-- Window creation
local Window = WindUI:CreateWindow({
    Title = "Fryzer Hub",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Author = "Selective Item Bring System",
    Folder = "Version 1.0",
    Size = UDim2.fromOffset(500, 400),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 180,
    ScrollBarEnabled = true,
    
    User = {
        Enabled = true,
        Anonymous = false,
        Username = LocalPlayer.DisplayName,
        UserId = LocalPlayer.UserId,
        Callback = function()
            print("User icon clicked:", LocalPlayer.Name)
        end
    }
})

-- UI open button
Window:EditOpenButton({
    Title = "OPEN",
    Icon = "door-open",
    CornerRadius = UDim.new(0, 16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("00D4FF"), Color3.fromHex("FF0080")),
    Draggable = true,
})

-- Info Tab
Tabs.InfoTab = Window:Tab({
    Title = "Info",
    Icon = "info",
    Desc = "Player information and Discord community"
})

Tabs.InfoTab:Paragraph({
    Title = "üë§ " .. PlayerName,
    Desc = string.format(
        "üè∑Ô∏è Username: @%s\nüéÇ Account Age: %d days\nüÜî User ID: %d\nüéÆ Current Game: %s\nüë• Server: %d/%d players\nüìç Region: %s",
        Player.Name, AccountAge, Player.UserId, GameName,
        #Players:GetPlayers(), Players.MaxPlayers,
        game:GetService("LocalizationService").RobloxLocaleId
    ),
    Image = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. Player.UserId .. "&width=150&height=150&format=png",
    ImageSize = 52,
})

-- Discord Section
Tabs.InfoTab:Paragraph({
    Title = "Join Our Discord Community",
    Desc = "Connect with other users, get support, and stay updated!",
    Image = "users",
    Color = "Blue",
})

Tabs.InfoTab:Button({
    Title = "Copy Discord Link",
    Desc = "Copy invite link to clipboard",
    Callback = function()
        setclipboard("https://discord.gg/rpE4Eet7")
        WindUI:Notify({
            Title = "Link Copied!",
            Content = "Discord link copied to clipboard",
            Duration = 3,
            Icon = "copy",
        })
    end
})

-- Player Tab
Tabs.PlayerTab = Window:Tab({
    Title = "Player",
    Icon = "user",
    Desc = "Player movement and control features"
})

Tabs.PlayerTab:Paragraph({
    Title = "Player Controls",
    Desc = "Use the buttons below to control your player character",
    Image = "user-check",
    Color = "Blue",
})

-- ========================================
-- SIMPLE WINDUI MOVEMENT SYSTEM
-- WalkSpeed, JumpHeight, Noclip, Instant Prompts
-- ========================================

-- Additional Player Features
Tabs.PlayerTab:Button({
    Title = "Health Booster",
    Desc = "Restore your health to 100",
    Callback = function()
        local localPlayer = game.Players.LocalPlayer
        if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
            localPlayer.Character.Humanoid.Health = 100
            WindUI:Notify({
                Title = "Health Boosted! ‚ù§Ô∏è",
                Content = "Your health has been set to 100",
                Duration = 2,
            })
        else
            WindUI:Notify({
                Title = "Error!",
                Content = "Character or Humanoid not found",
                Duration = 2,
            })
        end
    end
})

-- Infinite Jump Toggle
local infiniteJumpEnabled = false
local player = Players.LocalPlayer

Tabs.PlayerTab:Toggle({
    Title = "Infinite Jump",
    Icon = "arrow-up",
    Value = false,
    Callback = function(state)
        infiniteJumpEnabled = state
        WindUI:Notify({
            Title = state and "Infinite Jump Enabled! üöÄ" or "Infinite Jump Disabled!",
            Content = state and "Press Space to jump infinitely" or "Jump mechanics restored to normal",
            Duration = 3,
        })
    end
})

-- Infinite Jump Script
UserInputService.JumpRequest:Connect(function()
    if infiniteJumpEnabled and player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        if humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

-- Movement States
local ActiveSpeedBoost = false
local ActiveJumpBoost = false
local ActiveNoclip = false
local ActiveInstantPrompts = false

local ValueSpeed = 16
local ValueJumpHeight = 7.2
local OldSpeed = 16
local OldJumpHeight = 7.2

-- ========================================
-- UTILITY FUNCTIONS
-- ========================================

local function getCharacter()
    return LocalPlayer.Character
end

local function getHumanoid()
    local character = getCharacter()
    return character and character:FindFirstChildOfClass("Humanoid")
end

-- ========================================
-- CHARACTER RESPAWN HANDLER
-- ========================================

local function updateOriginalValues()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        OldSpeed = LocalPlayer.Character.Humanoid.WalkSpeed
        OldJumpHeight = LocalPlayer.Character.Humanoid.JumpHeight or 7.2
    end
end

updateOriginalValues()
LocalPlayer.CharacterAdded:Connect(updateOriginalValues)

-- ========================================
-- WINDUI INTERFACE - PLAYER TAB
-- ========================================

-- Instant Prompts Control
Tabs.PlayerTab:Toggle({
    Title = "Instant Open Chests",
    Icon = "zap-off",
    Value = false,
    Callback = function(state)
        ActiveInstantPrompts = state
        
        task.spawn(function()
            if ActiveInstantPrompts then
                -- Enable instant prompts
                for _, prompt in pairs(game.Workspace:GetDescendants()) do  
                    if prompt:IsA("ProximityPrompt") and prompt.HoldDuration ~= 0 then 
                        prompt:SetAttribute("HoldDurationOld", prompt.HoldDuration)
                        prompt.HoldDuration = 0
                    end 
                end
                
                -- Monitor for new prompts
                local promptConnection
                promptConnection = game.Workspace.DescendantAdded:Connect(function(descendant)
                    if ActiveInstantPrompts and descendant:IsA("ProximityPrompt") and descendant.HoldDuration ~= 0 then
                        descendant:SetAttribute("HoldDurationOld", descendant.HoldDuration)
                        descendant.HoldDuration = 0
                    end
                end)
                
                -- Keep connection active while enabled
                while ActiveInstantPrompts do
                    task.wait(1)
                end
                
                -- Cleanup when disabled
                if promptConnection then
                    promptConnection:Disconnect()
                end
            else 
                -- Restore original prompt durations
                for _, prompt in pairs(game.Workspace:GetDescendants()) do  
                    if prompt:IsA("ProximityPrompt") and prompt:GetAttribute("HoldDurationOld") then 
                        prompt.HoldDuration = prompt:GetAttribute("HoldDurationOld")
                        prompt:SetAttribute("HoldDurationOld", nil)
                    end 
                end  
            end
        end)
        
        print("‚ö° Instant Prompts: " .. (state and "ON" or "OFF"))
    end
})

-- Speed Controls Section
Tabs.PlayerTab:Slider({
    Title = "Walk Speed Setting",
    Value = { Min = 16, Max = 500, Default = 16 },
    Callback = function(value)
        ValueSpeed = value
        print("üèÉ Walk speed set to: " .. value)
    end
})

Tabs.PlayerTab:Toggle({
    Title = "Enable Speed Boost",
    Icon = "zap",
    Value = false,
    Callback = function(state)
        ActiveSpeedBoost = state
        
        task.spawn(function()
            while ActiveSpeedBoost do
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    LocalPlayer.Character.Humanoid.WalkSpeed = ValueSpeed
                end
                task.wait(0.1)
            end
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = OldSpeed
            end
        end)
        
        print("üèÉ Speed Boost: " .. (state and "ON" or "OFF"))
    end
})

-- Jump Controls Section
Tabs.PlayerTab:Slider({
    Title = "Jump Height Setting",
    Value = { Min = 7, Max = 200, Default = 50 },
    Callback = function(value)
        ValueJumpHeight = value
        print("ü¶ò Jump height set to: " .. value)
    end
})

Tabs.PlayerTab:Toggle({
    Title = "Enable Jump Boost",
    Icon = "move-up",
    Value = false,
    Callback = function(state)
        ActiveJumpBoost = state
        
        task.spawn(function()
            while ActiveJumpBoost do
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    local humanoid = LocalPlayer.Character.Humanoid
                    -- Force JumpHeight mode for consistency
                    humanoid.UseJumpPower = false
                    humanoid.JumpHeight = ValueJumpHeight
                end
                task.wait(0.1)
            end
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                local humanoid = LocalPlayer.Character.Humanoid
                -- Restore original jump settings
                humanoid.JumpHeight = 7.2  -- Default Roblox jump height
            end
        end)
        
        print("ü¶ò Jump Boost: " .. (state and "ON" or "OFF"))
    end
})

-- Noclip Control
Tabs.PlayerTab:Toggle({
    Title = "Noclip Mode",
    Icon = "ghost",
    Value = false,
    Callback = function(state)
        ActiveNoclip = state
        
        task.spawn(function()
            while ActiveNoclip do 
                if LocalPlayer.Character then
                    for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide then
                            part.CanCollide = false
                        end
                    end
                end
                task.wait(0.1)
            end 
            if LocalPlayer.Character then
                for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") and not part.CanCollide then
                        part.CanCollide = true
                    end
                end
            end
        end)
        
        print("üëª Noclip: " .. (state and "ON" or "OFF"))
    end
})

print("üöÄ Simple Movement System loaded!")
print("üìù Features: Walk Speed, Jump Height, Noclip, Instant Prompts")

-- Fly System
local IYMouse = Players.LocalPlayer:GetMouse()
local FLYING = false
local QEfly = true
local iyflyspeed = 1
local vehicleflyspeed = 1
local ActivateFly = false

local function sFLY(vfly)
    repeat wait() until Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart") and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    repeat wait() until IYMouse
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end

    local T = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0

    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro')
        local BV = Instance.new('BodyVelocity')
        BG.P = 9e4
        BG.Parent = T
        BV.Parent = T
        BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.CFrame = T.CFrame
        BV.Velocity = Vector3.new(0, 0, 0)
        BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            repeat wait()
                if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                    Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = 50
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.Velocity = Vector3.new(0, 0, 0)
                end
                BG.CFrame = workspace.CurrentCamera.CoordinateFrame
            until not FLYING
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:Destroy()
            BV:Destroy()
            if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
            end
        end)
    end
    flyKeyDown = IYMouse.KeyDown:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 's' then
            CONTROL.B = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'a' then
            CONTROL.L = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'd' then 
            CONTROL.R = (vfly and vehicleflyspeed or iyflyspeed)
        elseif QEfly and KEY:lower() == 'e' then
            CONTROL.Q = (vfly and vehicleflyspeed or iyflyspeed)*2
        elseif QEfly and KEY:lower() == 'q' then
            CONTROL.E = -(vfly and vehicleflyspeed or iyflyspeed)*2
        end
        pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
    end)
    flyKeyUp = IYMouse.KeyUp:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = 0
        elseif KEY:lower() == 's' then
            CONTROL.B = 0
        elseif KEY:lower() == 'a' then
            CONTROL.L = 0
        elseif KEY:lower() == 'd' then
            CONTROL.R = 0
        elseif KEY:lower() == 'e' then
            CONTROL.Q = 0
        elseif KEY:lower() == 'q' then
            CONTROL.E = 0
        end
    end)
    FLY()
end

local function NOFLY()
    FLYING = false
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end
    if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
        Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
    end
    pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

-- Mobile Fly Functions
local velocityHandlerName = "BodyVelocity"
local gyroHandlerName = "BodyGyro"
local mfly1
local mfly2

local function UnMobileFly()
    pcall(function()
        FLYING = false
        local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        root:FindFirstChild(velocityHandlerName):Destroy()
        root:FindFirstChild(gyroHandlerName):Destroy()
        Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
        mfly1:Disconnect()
        mfly2:Disconnect()
    end)
end

local function MobileFly()
    UnMobileFly()
    FLYING = true

    local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local camera = workspace.CurrentCamera
    local v3none = Vector3.new()
    local v3zero = Vector3.new(0, 0, 0)
    local v3inf = Vector3.new(9e9, 9e9, 9e9)

    local controlModule = require(Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    local bv = Instance.new("BodyVelocity")
    bv.Name = velocityHandlerName
    bv.Parent = root
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = gyroHandlerName
    bg.Parent = root
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50

    mfly1 = Players.LocalPlayer.CharacterAdded:Connect(function()
        local bv = Instance.new("BodyVelocity")
        bv.Name = velocityHandlerName
        bv.Parent = root
        bv.MaxForce = v3zero
        bv.Velocity = v3zero

        local bg = Instance.new("BodyGyro")
        bg.Name = gyroHandlerName
        bg.Parent = root
        bg.MaxTorque = v3inf
        bg.P = 1000
        bg.D = 50
    end)

    mfly2 = RunService.RenderStepped:Connect(function()
        root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        camera = workspace.CurrentCamera
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
            local humanoid = Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
            local VelocityHandler = root:FindFirstChild(velocityHandlerName)
            local GyroHandler = root:FindFirstChild(gyroHandlerName)

            VelocityHandler.MaxForce = v3inf
            GyroHandler.MaxTorque = v3inf
            humanoid.PlatformStand = true
            GyroHandler.CFrame = camera.CoordinateFrame
            VelocityHandler.Velocity = v3none

            local direction = controlModule:GetMoveVector()
            if direction.X > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.X < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.Z > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
            if direction.Z < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
        end
    end)
end

-- Fly Speed Slider
Tabs.PlayerTab:Slider({
    Title = "Fly Speed",
    Value = {
        Min = 0.1,
        Max = 10,
        Default = 1
    },
    Callback = function(val)
        iyflyspeed = val
    end
})

-- Fly Toggle
Tabs.PlayerTab:Toggle({
    Title = "Fly", 
    Value = false,
    Callback = function(state)
        ActivateFly = state
        task.spawn(function()
            if not FLYING and ActivateFly then
                if UserInputService.TouchEnabled then
                    MobileFly()
                else
                    NOFLY()
                    wait()
                    sFLY()
                end
            elseif FLYING and not ActivateFly then
                if UserInputService.TouchEnabled then
                    UnMobileFly()
                else
                    NOFLY()
                end
            end
        end)
    end
})

-- SELECTIVE ITEM BRING SYSTEM VARIABLES
local isSystemRunning = false
local originalCameraSubject
local originalPlayerPosition = nil
local searchConnection
local fastModeEnabled = false
local inputConnections = {}
local cameraPart = nil

-- ORGANIZED ITEM SECTIONS - EASILY ADD MORE SECTIONS AND ITEMS
local itemSections = {
    ["Wood Types"] = {
        sectionIcon = "üå≥",
        items = {
            ["Oak_Log"] = {enabled = false, path = "workspace.Items.Oak_Log", displayName = "üå≥ Oak Log"},
            ["Pine_Log"] = {enabled = false, path = "workspace.Items.Pine_Log", displayName = "üå≤ Pine Log"},
            ["Birch_Log"] = {enabled = false, path = "workspace.Items.Birch_Log", displayName = "üåø Birch Log"},
            ["Cherry_Log"] = {enabled = false, path = "workspace.Items.Cherry_Log", displayName = "üå∏ Cherry Log"},
            ["Wood_Plank"] = {enabled = false, path = "workspace.Items.Wood_Plank", displayName = "ü™µ Wood Plank"},
        }
    },
    
    ["Food"] = {
        sectionIcon = "üçé",
        items = {
            ["Apple"] = {enabled = false, path = "workspace.Items.Apple", displayName = "üçé Apple"},
            ["Berry"] = {enabled = false, path = "workspace.Items.Berry", displayName = "ü´ê Berry"},
            ["Fish"] = {enabled = false, path = "workspace.Items.Fish", displayName = "üêü Fish"},
            ["Meat"] = {enabled = false, path = "workspace.Items.Meat", displayName = "ü•© Meat"},
            ["Bread"] = {enabled = false, path = "workspace.Items.Bread", displayName = "üçû Bread"},
            ["Mushroom"] = {enabled = false, path = "workspace.Items.Mushroom", displayName = "üçÑ Mushroom"},
        }
    },
    
    ["Weapons"] = {
        sectionIcon = "‚öîÔ∏è",
        items = {
            ["Sword"] = {enabled = false, path = "workspace.Items.Sword", displayName = "‚öîÔ∏è Sword"},
            ["Bow"] = {enabled = false, path = "workspace.Items.Bow", displayName = "üèπ Bow"},
            ["Axe"] = {enabled = false, path = "workspace.Items.Axe", displayName = "ü™ì Axe"},
            ["Spear"] = {enabled = false, path = "workspace.Items.Spear", displayName = "üî± Spear"},
            ["Dagger"] = {enabled = false, path = "workspace.Items.Dagger", displayName = "üó°Ô∏è Dagger"},
        }
    },
    
    ["Basic Resources"] = {
        sectionIcon = "ü™®",
        items = {
            ["Stone"] = {enabled = false, path = "workspace.Items.Stone", displayName = "ü™® Stone"},
            ["Iron"] = {enabled = false, path = "workspace.Items.Iron", displayName = "‚öíÔ∏è Iron"},
            ["Coal"] = {enabled = false, path = "workspace.Items.Coal", displayName = "‚ö´ Coal"},
            ["Stick"] = {enabled = false, path = "workspace.Items.Stick", displayName = "üèïÔ∏è Stick"},
            ["Rock"] = {enabled = false, path = "workspace.Items.Rock", displayName = "üóø Rock"},
        }
    },
    
    ["Rare Materials"] = {
        sectionIcon = "üíé",
        items = {
            ["Diamond"] = {enabled = false, path = "workspace.Items.Diamond", displayName = "üíé Diamond"},
            ["Gold"] = {enabled = false, path = "workspace.Items.Gold", displayName = "ü™ô Gold"},
            ["Silver"] = {enabled = false, path = "workspace.Items.Silver", displayName = "‚ö™ Silver"},
            ["Ruby"] = {enabled = false, path = "workspace.Items.Ruby", displayName = "üî¥ Ruby"},
            ["Emerald"] = {enabled = false, path = "workspace.Items.Emerald", displayName = "üü¢ Emerald"},
        }
    },
    
    ["Crafting Materials"] = {
        sectionIcon = "üß™",
        items = {
            ["Rope"] = {enabled = false, path = "workspace.Items.Rope", displayName = "ü™¢ Rope"},
            ["Cloth"] = {enabled = false, path = "workspace.Items.Cloth", displayName = "üßµ Cloth"},
            ["Leather"] = {enabled = false, path = "workspace.Items.Leather", displayName = "ü¶¥ Leather"},
            ["Glue"] = {enabled = false, path = "workspace.Items.Glue", displayName = "üß™ Glue"},
        }
    },
    
    ["Liquids"] = {
        sectionIcon = "üíß",
        items = {
            ["Water"] = {enabled = false, path = "workspace.Items.Water", displayName = "üíß Water"},
            ["Oil"] = {enabled = false, path = "workspace.Items.Oil", displayName = "üõ¢Ô∏è Oil"},
            ["Honey"] = {enabled = false, path = "workspace.Items.Honey", displayName = "üçØ Honey"},
        }
    },
}

-- Convert sections to flat itemToggles for backward compatibility
local itemToggles = {}
for sectionName, sectionData in pairs(itemSections) do
    for itemName, itemData in pairs(sectionData.items) do
        itemToggles[itemName] = itemData
    end
end

-- Store original player state
local function saveOriginalState()
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        originalPlayerPosition = char.HumanoidRootPart.CFrame
        print("üíæ Original position saved:", originalPlayerPosition.Position)
    end
end

-- Return to original position
local function returnToOriginalPosition()
    if originalPlayerPosition and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = originalPlayerPosition
        print("üè† Returned to original position")
        WindUI:Notify({
            Title = "üè† Position Restored",
            Content = "Teleported back to starting location",
            Duration = 3
        })
    end
end

-- Disable user inputs completely
local function disableInputs()
    for _, connection in pairs(inputConnections) do
        connection:Disconnect()
    end
    inputConnections = {}
    
    inputConnections[#inputConnections + 1] = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        local inputType = input.UserInputType
        local keyCode = input.KeyCode
        
        -- Block all movement keys
        if inputType == Enum.UserInputType.Keyboard then
            local blockedKeys = {
                Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D,
                Enum.KeyCode.Space, Enum.KeyCode.LeftShift, Enum.KeyCode.LeftControl,
                Enum.KeyCode.Q, Enum.KeyCode.E, Enum.KeyCode.R, Enum.KeyCode.T,
                Enum.KeyCode.F, Enum.KeyCode.G, Enum.KeyCode.H, Enum.KeyCode.J,
                Enum.KeyCode.K, Enum.KeyCode.L, Enum.KeyCode.Z, Enum.KeyCode.X,
                Enum.KeyCode.C, Enum.KeyCode.V, Enum.KeyCode.B, Enum.KeyCode.N,
                Enum.KeyCode.M, Enum.KeyCode.Up, Enum.KeyCode.Down,
                Enum.KeyCode.Left, Enum.KeyCode.Right
            }
            
            for _, blockedKey in pairs(blockedKeys) do
                if keyCode == blockedKey then
                    return
                end
            end
        end
        
        -- Block mouse inputs
        if inputType == Enum.UserInputType.MouseButton1 or 
           inputType == Enum.UserInputType.MouseButton2 or
           inputType == Enum.UserInputType.MouseButton3 then
            return
        end
    end)
    
    -- Freeze character movement
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local humanoid = LocalPlayer.Character.Humanoid
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0
        humanoid.JumpHeight = 0
    end
    
    print("üîí All inputs disabled, character frozen")
end

-- Restore user inputs
local function enableInputs()
    for _, connection in pairs(inputConnections) do
        connection:Disconnect()
    end
    inputConnections = {}
    
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local humanoid = LocalPlayer.Character.Humanoid
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
        humanoid.JumpHeight = 7.2
    end
    
    print("üîì User inputs restored")
end

-- Find only SELECTED items based on toggles
local function findSelectedItems()
    local foundItems = {}
    
    for itemName, itemData in pairs(itemToggles) do
        if itemData.enabled then
            if workspace:FindFirstChild("Items") then
                for _, item in pairs(workspace.Items:GetChildren()) do
                    if item.Name == itemName then
                        table.insert(foundItems, {item = item, name = itemName})
                    end
                end
            end
            
            for _, descendant in pairs(workspace:GetDescendants()) do
                if (descendant:IsA("Model") or descendant:IsA("BasePart")) and descendant.Name == itemName then
                    if descendant.Parent ~= workspace.Items then
                        local itemPos = descendant:IsA("Model") and descendant.PrimaryPart and descendant.PrimaryPart.Position or 
                                       descendant:IsA("BasePart") and descendant.Position
                        
                        if itemPos and LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart then
                            local distance = (itemPos - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                            if distance > 30 then
                                table.insert(foundItems, {item = descendant, name = itemName})
                            end
                        end
                    end
                end
            end
        end
    end
    
    return foundItems
end

-- Get enabled items count
local function getEnabledItemsCount()
    local count = 0
    for itemName, itemData in pairs(itemToggles) do
        if itemData.enabled then
            count = count + 1
        end
    end
    return count
end

-- Get enabled items list
local function getEnabledItemsList()
    local items = {}
    for itemName, itemData in pairs(itemToggles) do
        if itemData.enabled then
            table.insert(items, itemName)
        end
    end
    return items
end

-- Get remote events
local function getRemoteEvents()
    local success, remoteEvents = pcall(function()
        return ReplicatedStorage:WaitForChild("RemoteEvents", 2)
    end)
    
    if not success or not remoteEvents then
        return nil, nil
    end
    
    local dragEvent = remoteEvents:FindFirstChild("RequestStartDraggingItem")
    local stopDragEvent = remoteEvents:FindFirstChild("StopDraggingItem")
    
    return dragEvent, stopDragEvent
end

-- Get item position helper
local function getItemPosition(item)
    if item:IsA("Model") then
        return item.PrimaryPart and item.PrimaryPart.Position or 
               (item:FindFirstChildWhichIsA("BasePart") and item:FindFirstChildWhichIsA("BasePart").Position)
    elseif item:IsA("BasePart") then
        return item.Position
    end
    return nil
end

-- Enhanced fast drag with position lock
local function fastDragItem(item, targetCFrame, itemName)
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    
    if not char or not hrp then
        return false
    end
    
    local dragEvent, stopDragEvent = getRemoteEvents()
    if not dragEvent or not stopDragEvent then
        return false
    end
    
    local itemPos = getItemPosition(item)
    if not itemPos then
        return false
    end
    
    if originalPlayerPosition then
        hrp.CFrame = originalPlayerPosition
    end
    
    local teleportHeight = fastModeEnabled and 15 or 25
    local approachHeight = fastModeEnabled and 1 or 2
    local moveHeight = fastModeEnabled and 8 or 12
    local steps = fastModeEnabled and 4 or 6
    local stepDelay = fastModeEnabled and 0.005 or 0.01
    local waitTime = fastModeEnabled and 0.03 or 0.08
    
    print("üéØ Bringing", itemName, fastModeEnabled and "(FAST)" or "(NORMAL)")
    
    hrp.CFrame = CFrame.new(itemPos + Vector3.new(0, teleportHeight, 0))
    wait(waitTime)
    
    hrp.CFrame = CFrame.new(itemPos + Vector3.new(0, approachHeight, 0))
    wait(waitTime * 0.5)
    
    pcall(function()
        dragEvent:FireServer(item)
    end)
    wait(waitTime)
    
    local itemPart = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")) or item
    
    if itemPart then
        local targetPos = targetCFrame.Position + Vector3.new(0, 12, 0)
        
        for i = 1, steps do
            if not isSystemRunning then break end
            
            if originalPlayerPosition then
                hrp.CFrame = originalPlayerPosition
            end
            
            local alpha = i / steps
            local newPos = itemPos:Lerp(targetPos, alpha)
            
            pcall(function()
                if itemPart.Parent then
                    itemPart.CFrame = CFrame.new(newPos)
                end
            end)
            
            wait(stepDelay)
        end
        
        pcall(function()
            if itemPart.Parent then
                itemPart.CFrame = CFrame.new(targetPos)
            end
        end)
        
        wait(waitTime * 0.5)
    end
    
    pcall(function()
        stopDragEvent:FireServer(item)
    end)
    
    if originalPlayerPosition then
        hrp.CFrame = originalPlayerPosition
    end
    
    return true
end

-- Return camera to player
local function returnCameraToPlayer()
    local camera = workspace.CurrentCamera
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        camera.CameraSubject = LocalPlayer.Character.Humanoid
        print("üìπ Camera returned to player")
    else
        camera.CameraSubject = originalCameraSubject
    end
end

-- Enhanced stop function with cleanup and return to start
function stopBringing()
    print("üõë Stopping selective bring system...")
    isSystemRunning = false
    
    if searchConnection then
        searchConnection:Disconnect()
        searchConnection = nil
    end
    
    spawn(function()
        if cameraPart then
            cameraPart:Destroy()
            cameraPart = nil
        end
        
        returnCameraToPlayer()
        
        enableInputs()
        
        wait(0.5)
        returnToOriginalPosition()
        
        WindUI:Notify({
            Title = "üõë System Stopped",
            Content = "Returned to start position, inputs restored!",
            Duration = 4
        })
        
        print("‚úÖ System fully stopped and reset")
    end)
end

-- Main selective continuous search and bring function
local function startSelectiveBring()
    local enabledCount = getEnabledItemsCount()
    if enabledCount == 0 then
        WindUI:Notify({
            Title = "‚ùå No Items Selected",
            Content = "Please enable at least one item type to bring!",
            Duration = 4
        })
        return
    end
    
    local enabledItems = getEnabledItemsList()
    print("üöÄ Starting selective bring system for:", table.concat(enabledItems, ", "))
    isSystemRunning = true
    
    saveOriginalState()
    
    disableInputs()
    
    local camera = workspace.CurrentCamera
    originalCameraSubject = camera.CameraSubject
    
    if originalPlayerPosition then
        cameraPart = Instance.new("Part")
        cameraPart.Name = "CameraPart"
        cameraPart.Anchored = true
        cameraPart.CanCollide = false
        cameraPart.Transparency = 1
        cameraPart.CFrame = originalPlayerPosition + Vector3.new(0, 8, 12)
        cameraPart.Parent = workspace
        
        camera.CameraSubject = cameraPart
        print("üìπ Camera locked to start position")
    end
    
    WindUI:Notify({
        Title = "üéÆ Selective System Active",
        Content = "Bringing " .. enabledCount .. " item types. Use the UI to stop.",
        Duration = 5
    })
    
    searchConnection = spawn(function()
        local searchInterval = 2
        local lastSearchTime = 0
        
        while isSystemRunning do
            local currentTime = tick()
            
            if currentTime - lastSearchTime >= searchInterval then
                lastSearchTime = currentTime
                
                if originalPlayerPosition and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    LocalPlayer.Character.HumanoidRootPart.CFrame = originalPlayerPosition
                end
                
                local foundItems = findSelectedItems()
                print("üîç Selective Search... Found:", #foundItems, "selected items")
                
                if #foundItems > 0 then
                    for _, itemData in pairs(foundItems) do
                        if not isSystemRunning then break end
                        
                        local item = itemData.item
                        local itemName = itemData.name
                        
                        local itemPos = getItemPosition(item)
                        if itemPos and originalPlayerPosition then
                            local distance = (itemPos - originalPlayerPosition.Position).Magnitude
                            local minDistance = fastModeEnabled and 5 or 8
                            
                            if distance > minDistance then
                                local success = pcall(fastDragItem, item, originalPlayerPosition, itemName)
                                if success then
                                    print("üì¶", itemName, "brought successfully!")
                                else
                                    print("‚ùå Failed to bring", itemName)
                                end
                                
                                wait(fastModeEnabled and 0.1 or 0.2)
                            else
                                print("üìç", itemName, "already nearby")
                            end
                        end
                    end
                else
                    print("‚ùå No selected items found in search")
                end
            end
            
            wait(0.1)
        end
    end)
end

-- SELECTIVE ITEM BRING TAB
Tabs.BringTab = Window:Tab({ 
    Title = "Selective Item Bring", 
    Icon = "target",
    Desc = "Selective item collection system"
})

Tabs.BringTab:Paragraph({
    Title = "üéØ Selective Item Bring System",
    Content = "Choose exactly which items to bring! Toggle individual item types on/off. System searches every 2 seconds for ONLY selected items."
})

Tabs.BringTab:Toggle({
    Title = "üîÑ Start Selective Bring System", 
    Desc = "Enable continuous bringing of selected items only",
    Value = false,
    Callback = function(state)
        if state then
            if not isSystemRunning then
                startSelectiveBring()
            else
                WindUI:Notify({
                    Title = "‚ö†Ô∏è Already Running",
                    Content = "System is already active!",
                    Duration = 3
                })
            end
        else
            if isSystemRunning then
                stopBringing()
            end
        end
        print("Selective Bring System:", state and "ENABLED" or "DISABLED")
    end
})

Tabs.BringTab:Toggle({
    Title = "‚ö° Fast Mode", 
    Desc = "Enable for faster bringing speeds",
    Value = false,
    Callback = function(state)
        fastModeEnabled = state
        print("Fast Mode:", state and "ENABLED" or "DISABLED")
        WindUI:Notify({
            Title = state and "Fast Mode ON" or "Normal Speed",
            Content = state and "Bringing will be faster!" or "Normal speed activated.",
            Duration = 3
        })
    end
})

for sectionName, sectionData in pairs(itemSections) do
    Tabs.BringTab:Paragraph({
        Title = sectionData.sectionIcon .. " " .. sectionName,
        Content = "Toggle " .. sectionName:lower() .. " items on/off individually"
    })
    
    for itemName, itemData in pairs(sectionData.items) do
        Tabs.BringTab:Toggle({
            Title = itemData.displayName, 
            Desc = "Bring " .. itemName .. " items automatically",
            Value = false,
            Callback = function(state)
                itemToggles[itemName].enabled = state
                print(itemName, "bringing:", state and "ENABLED" or "DISABLED")
                
                local enabledCount = getEnabledItemsCount()
                WindUI:Notify({
                    Title = state and ("‚úÖ " .. itemName .. " Enabled") or ("‚ùå " .. itemName .. " Disabled"),
                    Content = "Total enabled: " .. enabledCount .. " item types",
                    Duration = 2
                })
            end
        })
    end
end

Tabs.BringTab:Paragraph({
    Title = "‚ö° Quick Section Selection",
    Content = "Quick buttons to enable/disable entire sections at once."
})

for sectionName, sectionData in pairs(itemSections) do
    Tabs.BringTab:Button({
        Title = sectionData.sectionIcon .. " Enable All " .. sectionName,
        Desc = "Enable all items in " .. sectionName .. " section",
        Callback = function()
            local itemNames = {}
            for itemName, itemData in pairs(sectionData.items) do
                itemToggles[itemName].enabled = true
                table.insert(itemNames, itemName)
            end
            WindUI:Notify({
                Title = sectionData.sectionIcon .. " " .. sectionName .. " Enabled",
                Content = "Enabled: " .. table.concat(itemNames, ", "),
                Duration = 4
            })
        end
    })
end

Tabs.BringTab:Button({
    Title = "‚ùå Disable All Items",
    Desc = "Turn off all item types",
    Callback = function()
        for itemName, itemData in pairs(itemToggles) do
            itemToggles[itemName].enabled = false
        end
        WindUI:Notify({
            Title = "‚ùå All Disabled",
            Content = "All item types disabled!",
            Duration = 3
        })
    end
})

print("üéØ Selective Fryzer Hub Item Bring System loaded! üöÄ")
print("üìù To add more items, edit the 'itemToggles' table at the top of the script!")

-- Over Powered Tab
Tabs.OpTab = Window:Tab({
    Title = "Over Powered",
    Icon = "zap",
    Desc = "Over Powered System"
})

Tabs.OpTab:Paragraph({
    Title = "Warning",
    Desc = "Do not change the distance sliders below, they are set to optimal values.",
    Image = "check",
    Color = "Red",
})

-- Auto Chop Tree Script for WindUI
local ActiveAutoChopTree = false
local DistanceForAutoChopTree = 2500

Tabs.OpTab:Slider({
    Title = "Don't Change this",
    Value = {
        Min = 0,
        Max = 3000,
        Default = 2500
    },
    Callback = function(val)
        DistanceForAutoChopTree = val
        print("Auto Chop Tree distance set to:", val)
    end
})

Tabs.OpTab:Toggle({
    Title = "Auto Chop Tree", 
    Value = false,
    Callback = function(state)
        ActiveAutoChopTree = state
        print("Auto Chop Tree is now:", state)
        
        if ActiveAutoChopTree then
            task.spawn(function()
                while ActiveAutoChopTree do 
                    local player = game.Players.LocalPlayer
                    local character = player.Character or player.CharacterAdded:Wait()
                    local hrp = character:WaitForChild("HumanoidRootPart")
                    local weapon = (player.Inventory:FindFirstChild("Old Axe") or 
                                   player.Inventory:FindFirstChild("Good Axe") or 
                                   player.Inventory:FindFirstChild("Strong Axe") or 
                                   player.Inventory:FindFirstChild("Chainsaw"))
                    
                    task.spawn(function()
                        for _, tree in pairs(workspace.Map.Foliage:GetChildren()) do
                            if tree:IsA("Model") and (tree.Name == "Small Tree" or tree.Name == "TreeBig1" or tree.Name == "TreeBig2") and tree.PrimaryPart then
                                local distance = (tree.PrimaryPart.Position - hrp.Position).Magnitude
                                if distance <= DistanceForAutoChopTree then
                                    local result = game:GetService("ReplicatedStorage").RemoteEvents.ToolDamageObject:InvokeServer(tree, weapon, 999, hrp.CFrame)
                                end
                            end
                        end 
                    end)
                    
                    task.spawn(function()
                        for _, tree in pairs(workspace.Map.Landmarks:GetChildren()) do
                            if tree:IsA("Model") and (tree.Name == "Small Tree" or tree.Name == "TreeBig1" or tree.Name == "TreeBig2") and tree.PrimaryPart then
                                local distance = (tree.PrimaryPart.Position - hrp.Position).Magnitude
                                if distance <= DistanceForAutoChopTree then
                                    local result = game:GetService("ReplicatedStorage").RemoteEvents.ToolDamageObject:InvokeServer(tree, weapon, 999, hrp.CFrame)
                                end
                            end
                        end
                    end)
                    
                    wait(0.1)
                end
            end)
        end
    end
})

-- Auto Kill Aura Script for WindUI
local ActiveKillAura = false
local DistanceForKillAura = 2500

Tabs.OpTab:Slider({
    Title = "Don't Change this",
    Value = {
        Min = 25,
        Max = 10000,
        Default = 2500
    },
    Callback = function(val)
        DistanceForKillAura = val
        print("Kill Aura distance set to:", val)
    end
})

Tabs.OpTab:Toggle({
    Title = "Kill Aura", 
    Value = false,
    Callback = function(state)
        ActiveKillAura = state
        print("Kill Aura is now:", state)
        
        if ActiveKillAura then
            task.spawn(function()
                while ActiveKillAura do 
                    local player = game.Players.LocalPlayer
                    local character = player.Character or player.CharacterAdded:Wait()
                    local hrp = character:WaitForChild("HumanoidRootPart")
                    local weapon = (player.Inventory:FindFirstChild("Old Axe") or 
                                   player.Inventory:FindFirstChild("Good Axe") or 
                                   player.Inventory:FindFirstChild("Strong Axe") or 
                                   player.Inventory:FindFirstChild("Chainsaw"))
                    
                    task.spawn(function()
                        for _, enemy in pairs(workspace.Characters:GetChildren()) do
                            if enemy:IsA("Model") and enemy.PrimaryPart then
                                local distance = (enemy.PrimaryPart.Position - hrp.Position).Magnitude
                                if distance <= DistanceForKillAura then
                                    local result = game:GetService("ReplicatedStorage").RemoteEvents.ToolDamageObject:InvokeServer(enemy, weapon, 999, hrp.CFrame)
                                end
                            end
                        end
                    end)
                    
                    wait(0.1)
                end
            end)
        end
    end
})

-- Teleport Tab
Tabs.TpTab = Window:Tab({
    Title = "Teleport",
    Icon = "cloud",
    Desc = "Teleportation and sky platform controls"
})

-- Sky Platform Variables
local isOnPlatform = false
local skyPlatform = nil
local platformConnection = nil

-- Enhanced Teleport Function
local function safeTeleport(targetCFrame, locationName)
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        WindUI:Notify({
            Title = "‚ùå Teleport Failed",
            Content = "Character not found!",
            Duration = 3
        })
        return false
    end
    
    hrp.CFrame = targetCFrame
    WindUI:Notify({
        Title = "‚úÖ Teleported",
        Content = "Moved to " .. (locationName or "unknown location"),
        Duration = 3
    })
    return true
end

-- Create Sky Platform
local function createSkyPlatform(playerPosition)
    if skyPlatform then
        skyPlatform:Destroy()
    end
    
    skyPlatform = Instance.new("Part")
    skyPlatform.Name = "SkyPlatform"
    skyPlatform.Size = Vector3.new(50, 1, 50)
    skyPlatform.Position = Vector3.new(playerPosition.X, 200, playerPosition.Z)
    skyPlatform.Anchored = true
    skyPlatform.Transparency = 1
    skyPlatform.CanCollide = true
    skyPlatform.Parent = workspace
    
    platformConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and isOnPlatform then
            local playerPos = LocalPlayer.Character.HumanoidRootPart.Position
            if playerPos.Y > 150 then
                local distance = (Vector2.new(playerPos.X, playerPos.Z) - Vector2.new(skyPlatform.Position.X, skyPlatform.Position.Z)).Magnitude
                if distance > 20 then
                    skyPlatform.Position = Vector3.new(playerPos.X, 200, playerPos.Z)
                end
                local minSize = 100
                if skyPlatform.Size.X < minSize then
                    skyPlatform.Size = Vector3.new(minSize, 1, minSize)
                end
            end
        end
    end)
end

-- Teleport to Sky
local function teleportToSky()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        WindUI:Notify({
            Title = "‚ùå Error",
            Content = "Character not found!",
            Duration = 3
        })
        return
    end
    
    local humanoidRootPart = character.HumanoidRootPart
    createSkyPlatform(humanoidRootPart.Position)
    safeTeleport(CFrame.new(humanoidRootPart.Position.X, 205, humanoidRootPart.Position.Z), "Sky Platform")
    isOnPlatform = true
end

-- Teleport to Ground
local function teleportToGround()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        WindUI:Notify({
            Title = "‚ùå Error",
            Content = "Character not found!",
            Duration = 3
        })
        return
    end
    
    local humanoidRootPart = character.HumanoidRootPart
    local currentPosition = humanoidRootPart.Position
    local raycast = workspace:Raycast(Vector3.new(currentPosition.X, currentPosition.Y, currentPosition.Z), Vector3.new(0, -1000, 0))
    
    local targetY = raycast and (raycast.Position.Y + 5) or 50
    safeTeleport(CFrame.new(currentPosition.X, targetY, currentPosition.Z), "Ground")
    
    if skyPlatform then
        skyPlatform:Destroy()
        skyPlatform = nil
    end
    if platformConnection then
        platformConnection:Disconnect()
        platformConnection = nil
    end
    isOnPlatform = false
end

-- Sky Platform Toggle
Tabs.TpTab:Toggle({
    Title = "Sky Platform",
    Icon = "cloud",
    Desc = "Toggle to teleport to sky an platform",
    Value = false,
    Callback = function(state)
        if state then
            teleportToSky()
        else
            teleportToGround()
        end
        WindUI:Notify({
            Title = state and "Sky Platform ON" or "Sky Platform OFF",
            Content = state and "Teleported to sky platform" or "Returned to ground",
            Duration = 3
        })
    end
})

-- Teleport to Campfire Button
Tabs.TpTab:Button({
    Title = "Teleport to Campfire",
    Desc = "Quick teleport to campfire location",
    Callback = function()
        local targetPosition = Vector3.new(0.2976149320602417, 6.346785545349121, -0.043002475053071976)
        safeTeleport(CFrame.new(targetPosition), "Campfire")
    end
})

-- Lost Child Teleport System
local CharactersFolder = workspace:FindFirstChild("Characters")
local lostChildPaths = {
    "Lost Child",
    "Lost Child2",
    "Lost Child3",
    "Lost Child4"
}
local availableChildren = {}
local selectedChild = nil
local childDropdown = nil

-- Function to refresh available Lost Children
local function refreshLostChildren()
    availableChildren = {}
    
    if CharactersFolder then
        for _, childName in pairs(lostChildPaths) do
            local childModel = CharactersFolder:FindFirstChild(childName)
            if childModel and childModel:IsA("Model") then
                table.insert(availableChildren, childName)
            end
        end
    end
    
    if childDropdown then
        pcall(function()
            childDropdown:SetValues(availableChildren)
        end)
        
        if #availableChildren > 0 and not selectedChild then
            selectedChild = availableChildren[1]
            pcall(function()
                childDropdown:SetValue(selectedChild)
            end)
        elseif #availableChildren == 0 then
            selectedChild = nil
            pcall(function()
                childDropdown:SetValue("None")
            end)
        end
    end
    
    print("üë∂ Found", #availableChildren, "Lost Children available for teleport")
end

-- Function to get teleport position for a Lost Child
local function getLostChildTeleportPosition(childName)
    if not CharactersFolder then
        return nil
    end
    
    local childModel = CharactersFolder:FindFirstChild(childName)
    if not childModel then
        return nil
    end
    
    local rootPart = childModel:FindFirstChild("HumanoidRootPart")
    if rootPart then
        return rootPart.Position
    end
    
    local anyPart = childModel:FindFirstChildWhichIsA("BasePart")
    if anyPart then
        return anyPart.Position
    end
    
    if childModel.PrimaryPart then
        return childModel.PrimaryPart.Position
    end
    
    return nil
end

-- Function to teleport to selected Lost Child
local function teleportToLostChild(childName)
    if not childName or childName == "None" then
        WindUI:Notify({
            Title = "‚ùå No Lost Child Selected",
            Content = "Please select a Lost Child from the dropdown",
            Duration = 3
        })
        return
    end
    
    local targetPosition = getLostChildTeleportPosition(childName)
    if not targetPosition then
        WindUI:Notify({
            Title = "‚ùå Teleport Failed",
            Content = childName .. " not found or invalid position",
            Duration = 1
        })
        return
    end
    
    local teleportPosition = targetPosition + Vector3.new(0, 5, 0)
    safeTeleport(CFrame.new(teleportPosition), childName)
end

-- Initial refresh for Lost Children
refreshLostChildren()

-- Lost Child Selection Dropdown
childDropdown = Tabs.TpTab:Dropdown({
    Title = "Select Lost Child",
    Values = availableChildren,
    Value = availableChildren[1] or "None",
    Desc = "Choose a Lost Child to teleport to",
    Callback = function(selected)
        selectedChild = selected
        WindUI:Notify({
            Title = "üë∂ Child Selected",
            Content = "Selected: " .. (selected or "None"),
            Duration = 1
        })
    end
})

-- Teleport to Selected Lost Child Button
Tabs.TpTab:Button({
    Title = "Teleport to Selected Lost Child",
    Desc = "Teleport to the currently selected Lost Child",
    Callback = function()
        teleportToLostChild(selectedChild)
    end
})

-- Individual teleport buttons for each Lost Child
for _, childName in pairs(lostChildPaths) do
    Tabs.TpTab:Button({
        Title = "TP to " .. childName,
        Desc = "Direct teleport to " .. childName,
        Callback = function()
            teleportToLostChild(childName)
        end
    })
end

-- Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer

-- === Player ESP Tab ===
Tabs.PlayerEspTab = Window:Tab({
    Title = "Player ESP",
    Icon = "users",
    Desc = "ESP and health billboards for players"
})

-- Health Billboard System (Players)
local healthBillboardEnabled = false
local healthConnections = {}
local healthTracked = {}

local HEALTH_SETTINGS = {
    Name = "HealthBillboard",
    MaxDistance = 250,
    StudsOffset = Vector3.new(0, 3.5, 0),
    TextFont = Enum.Font.GothamBold,
    TextSize = 14,
    AlwaysOnTop = true,
    UpdateHz = 30,
    UseBar = true,
    BarHeight = 6,
    BorderThickness = 2.5
}

local function clamp(n, a, b) return math.max(a, math.min(b, n)) end

local function lerpColor(c1, c2, t)
    return Color3.new(
        c1.R + (c2.R - c1.R) * t,
        c1.G + (c2.G - c1.G) * t,
        c1.B + (c2.B - c1.B) * t
    )
end

local function colorByPercent(p)
    p = clamp(p, 0, 1)
    return lerpColor(Color3.fromRGB(255, 60, 60), Color3.fromRGB(60, 255, 90), p)
end

local function findHead(model)
    local head = model:FindFirstChild("Head")
    if head and head:IsA("BasePart") then return head end
    local best, bestY = nil, -math.huge
    for _, obj in ipairs(model:GetDescendants()) do
        if obj:IsA("BasePart") and obj.CanCollide then
            if obj.Position.Y > bestY then
                bestY = obj.Position.Y
                best = obj
            end
        end
    end
    return best
end

local function makeBillboard(humanoid, head, model)
    if healthTracked[humanoid] and healthTracked[humanoid].Parent then return healthTracked[humanoid] end

    local bb = Instance.new("BillboardGui")
    bb.Name = HEALTH_SETTINGS.Name
    bb.Adornee = head
    bb.AlwaysOnTop = HEALTH_SETTINGS.AlwaysOnTop
    bb.Size = UDim2.fromOffset(160, HEALTH_SETTINGS.UseBar and (26 + HEALTH_SETTINGS.BarHeight) or 26)
    bb.StudsOffset = HEALTH_SETTINGS.StudsOffset
    bb.MaxDistance = HEALTH_SETTINGS.MaxDistance
    bb.ResetOnSpawn = false
    bb.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    bb.Parent = head

    local holder = Instance.new("Frame")
    holder.Size = UDim2.fromScale(1, 1)
    holder.BackgroundTransparency = 1
    holder.Parent = bb

    local text = Instance.new("TextLabel")
    text.Name = "HPText"
    text.Size = UDim2.new(1, -12, 0, 24)
    text.Position = UDim2.fromOffset(6, 2)
    text.BackgroundTransparency = 1
    text.TextColor3 = Color3.new(1, 1, 1)
    text.TextStrokeTransparency = 0.5
    text.Font = HEALTH_SETTINGS.TextFont
    text.TextSize = HEALTH_SETTINGS.TextSize
    text.Parent = holder

    local barFrame, barFill
    if HEALTH_SETTINGS.UseBar then
        barFrame = Instance.new("Frame")
        barFrame.Name = "Bar"
        barFrame.Size = UDim2.new(1, -12, 0, HEALTH_SETTINGS.BarHeight)
        barFrame.Position = UDim2.fromOffset(6, 26)
        barFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        barFrame.BorderSizePixel = HEALTH_SETTINGS.BorderThickness
        barFrame.Parent = holder

        barFill = Instance.new("Frame")
        barFill.Name = "Fill"
        barFill.Size = UDim2.fromScale(1, 1)
        barFill.BackgroundColor3 = Color3.fromRGB(60, 255, 90)
        barFill.BorderSizePixel = 0
        barFill.Parent = barFrame
    end

    healthTracked[humanoid] = bb

    local lastDisplayPct = 1
    local function update()
        if not healthBillboardEnabled then return end
        local hp = clamp(humanoid.Health, 0, math.max(1, humanoid.MaxHealth))
        local maxHp = math.max(1, humanoid.MaxHealth)
        local pct = hp / maxHp
        text.Text = string.format("%d / %d", math.floor(hp + 0.5), math.floor(maxHp + 0.5))

        if barFill then
            lastDisplayPct = lastDisplayPct + (pct - lastDisplayPct) * 0.35
            barFill.Size = UDim2.fromScale(lastDisplayPct, 1)
            barFill.BackgroundColor3 = colorByPercent(lastDisplayPct)
        else
            text.TextColor3 = colorByPercent(pct)
        end
    end

    local healthConn = humanoid.HealthChanged:Connect(update)
    local maxHealthConn = humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(update)
    local diedConn = humanoid.Died:Connect(function()
        if healthTracked[humanoid] then
            healthTracked[humanoid]:Destroy()
            healthTracked[humanoid] = nil
        end
    end)
    local heartbeatConn = RunService.Heartbeat:Connect(update)

    healthConnections[humanoid] = {healthConn, maxHealthConn, diedConn, heartbeatConn}

    update()
    return bb
end

local function attachToModel(model)
    if not model or not model:IsA("Model") then return end
    if Players:GetPlayerFromCharacter(model) == LocalPlayer then return end
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local head = findHead(model)
    if not head then return end
    makeBillboard(humanoid, head, model)
end

local function enableHealthBillboards()
    healthBillboardEnabled = true
    for _, hum in ipairs(workspace:GetDescendants()) do
        if hum:IsA("Humanoid") and hum.Parent and hum.Parent:IsA("Model") then
            attachToModel(hum.Parent)
        end
    end

    healthConnections.descendantAdded = workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("Humanoid") then
            local model = obj.Parent
            if model and model:IsA("Model") then
                task.defer(function()
                    attachToModel(model)
                end)
            end
        end
    end)

    healthConnections.playerAdded = Players.PlayerAdded:Connect(function(plr)
        plr.CharacterAdded:Connect(function(char)
            task.defer(function()
                attachToModel(char)
            end)
        end)
    end)

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character then attachToModel(plr.Character) end
        plr.CharacterAdded:Connect(function(char)
            task.defer(function()
                attachToModel(char)
            end)
        end)
    end

    WindUI:Notify({
        Title = "‚úÖ Health Billboards",
        Content = "Enabled for players",
        Duration = 3
    })
end

local function disableHealthBillboards()
    healthBillboardEnabled = false
    for humanoid, connList in pairs(healthConnections) do
        if type(connList) == "table" then
            for _, conn in ipairs(connList) do
                conn:Disconnect()
            end
        elseif connList.Disconnect then
            connList:Disconnect()
        end
    end
    healthConnections = {}

    for humanoid, billboard in pairs(healthTracked) do
        if billboard and billboard.Parent then
            billboard:Destroy()
        end
    end
    healthTracked = {}

    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BillboardGui") and obj.Name == HEALTH_SETTINGS.Name then
            obj:Destroy()
        end
    end

    WindUI:Notify({
        Title = "‚ùå Health Billboards",
        Content = "Disabled for players",
        Duration = 3
    })
end

-- Player ESP System
local playerESPEnabled = false
local trackedPlayers = {}
local espConnections = {}

local ESP_SETTINGS = {
    FillColor = Color3.fromRGB(255, 0, 0),
    FillTransparency = 0.8,
    OutlineColor = Color3.fromRGB(255, 255, 255),
    OutlineTransparency = 0,
    TextColor = Color3.fromRGB(255, 255, 255),
    TextSize = 14,
    MaxDistance = 1000,
    ShowDistance = true,
    ShowHealth = true,
    ShowNames = true,
    HealthBarEnabled = true,
    HealthBarHeight = 4
}

local function createPlayerESP(player)
    if player == LocalPlayer then return end
    if not player.Character then return end
    if trackedPlayers[player] then return end

    local character = player.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not rootPart then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "PlayerESP_Highlight"
    highlight.Adornee = character
    highlight.FillColor = ESP_SETTINGS.FillColor
    highlight.FillTransparency = ESP_SETTINGS.FillTransparency
    highlight.OutlineColor = ESP_SETTINGS.OutlineColor
    highlight.OutlineTransparency = ESP_SETTINGS.OutlineTransparency
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = character
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "PlayerESP_Billboard"
    billboard.Size = UDim2.new(0, 200, 0, 100)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.MaxDistance = ESP_SETTINGS.MaxDistance
    billboard.Adornee = rootPart
    billboard.Parent = rootPart
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 1
    frame.Parent = billboard
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, 0, 0, 20)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.DisplayName
    nameLabel.TextColor3 = ESP_SETTINGS.TextColor
    nameLabel.TextSize = ESP_SETTINGS.TextSize
    nameLabel.TextStrokeTransparency = 0.5
    nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.Parent = frame
    
    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Name = "DistanceLabel"
    distanceLabel.Size = UDim2.new(1, 0, 0, 15)
    distanceLabel.Position = UDim2.new(0, 0, 0, 20)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Text = "0m"
    distanceLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    distanceLabel.TextSize = ESP_SETTINGS.TextSize - 2
    distanceLabel.TextStrokeTransparency = 0.5
    distanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    distanceLabel.Font = Enum.Font.Gotham
    distanceLabel.Parent = frame
    
    local healthLabel = Instance.new("TextLabel")
    healthLabel.Name = "HealthLabel"
    healthLabel.Size = UDim2.new(1, 0, 0, 15)
    healthLabel.Position = UDim2.new(0, 0, 0, 35)
    healthLabel.BackgroundTransparency = 1
    healthLabel.Text = "100/100"
    healthLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    healthLabel.TextSize = ESP_SETTINGS.TextSize - 2
    healthLabel.TextStrokeTransparency = 0.5
    healthLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    healthLabel.Font = Enum.Font.Gotham
    healthLabel.Parent = frame
    
    local healthBarBG = Instance.new("Frame")
    healthBarBG.Name = "HealthBarBG"
    healthBarBG.Size = UDim2.new(1, 0, 0, ESP_SETTINGS.HealthBarHeight)
    healthBarBG.Position = UDim2.new(0, 0, 0, 50)
    healthBarBG.BackgroundColor3 = Color3.new(0, 0, 0)
    healthBarBG.BorderSizePixel = 1
    healthBarBG.BorderColor3 = Color3.new(1, 1, 1)
    healthBarBG.Parent = frame
    
    local healthBarFill = Instance.new("Frame")
    healthBarFill.Name = "HealthBarFill"
    healthBarFill.Size = UDim2.new(1, 0, 1, 0)
    healthBarFill.Position = UDim2.new(0, 0, 0, 0)
    healthBarFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    healthBarFill.BorderSizePixel = 0
    healthBarFill.Parent = healthBarBG
    
    local function updateESP()
        if not playerESPEnabled then return end
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
        
        local playerRoot = player.Character.HumanoidRootPart
        local localRoot = LocalPlayer.Character.HumanoidRootPart
        local playerHumanoid = player.Character:FindFirstChildOfClass("Humanoid")
        
        if not playerRoot or not localRoot or not playerHumanoid then return end
        
        if ESP_SETTINGS.ShowDistance then
            local distance = (localRoot.Position - playerRoot.Position).Magnitude
            distanceLabel.Text = math.floor(distance) .. "m"
            distanceLabel.Visible = true
        else
            distanceLabel.Visible = false
        end
        
        if ESP_SETTINGS.ShowHealth then
            local health = math.floor(playerHumanoid.Health)
            local maxHealth = math.floor(playerHumanoid.MaxHealth)
            local healthPercent = health / maxHealth
            
            healthLabel.Text = health .. "/" .. maxHealth
            healthLabel.Visible = true
            
            if ESP_SETTINGS.HealthBarEnabled then
                healthBarBG.Visible = true
                healthBarFill.Size = UDim2.new(healthPercent, 0, 1, 0)
                
                if healthPercent > 0.6 then
                    healthBarFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                    healthLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
                elseif healthPercent > 0.3 then
                    healthBarFill.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
                    healthLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
                else
                    healthBarFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                    healthLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
                end
            else
                healthBarBG.Visible = false
            end
        else
            healthLabel.Visible = false
            healthBarBG.Visible = false
        end
        
        if ESP_SETTINGS.ShowNames then
            nameLabel.Text = player.DisplayName
            nameLabel.Visible = true
        else
            nameLabel.Visible = false
        end
    end
    
    trackedPlayers[player] = {
        highlight = highlight,
        billboard = billboard,
        updateFunction = updateESP
    }
    
    local connection = RunService.Heartbeat:Connect(updateESP)
    espConnections[player] = { heartbeat = connection }
    
    local removeConnection = Players.PlayerRemoving:Connect(function(removedPlayer)
        if removedPlayer == player then
            removePlayerESP(player)
        end
    end)
    espConnections[player].removeConnection = removeConnection
    
    updateESP()
end

local function removePlayerESP(player)
    if trackedPlayers[player] then
        if trackedPlayers[player].highlight then
            trackedPlayers[player].highlight:Destroy()
        end
        if trackedPlayers[player].billboard then
            trackedPlayers[player].billboard:Destroy()
        end
        trackedPlayers[player] = nil
    end
    
    if espConnections[player] then
        if espConnections[player].heartbeat then
            espConnections[player].heartbeat:Disconnect()
        end
        if espConnections[player].removeConnection then
            espConnections[player].removeConnection:Disconnect()
        end
        espConnections[player] = nil
    end
end

local function enablePlayerESP()
    playerESPEnabled = true
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            createPlayerESP(player)
        end
    end
    
    espConnections.playerAdded = Players.PlayerAdded:Connect(function(player)
        if playerESPEnabled then
            player.CharacterAdded:Connect(function(character)
                if playerESPEnabled then
                    task.wait(1)
                    createPlayerESP(player)
                end
            end)
        end
    end)
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            player.CharacterAdded:Connect(function(character)
                if playerESPEnabled then
                    task.wait(1)
                    createPlayerESP(player)
                end
            end)
        end
    end
    
    WindUI:Notify({
        Title = "‚úÖ Player ESP",
        Content = "Enabled for players",
        Duration = 3
    })
end

local function disablePlayerESP()
    playerESPEnabled = false
    
    for player, _ in pairs(trackedPlayers) do
        removePlayerESP(player)
    end
    
    if espConnections.playerAdded then
        espConnections.playerAdded:Disconnect()
        espConnections.playerAdded = nil
    end
    
    espConnections = {}
    
    WindUI:Notify({
        Title = "‚ùå Player ESP",
        Content = "Disabled for players",
        Duration = 3
    })
end

-- Player ESP Controls
Tabs.PlayerEspTab:Paragraph({
    Title = "Player ESP System",
    Desc = "Advanced ESP system for tracking other players",
    Image = "users",
    Color = "Blue"
})

Tabs.PlayerEspTab:Toggle({
    Title = "Health Billboard",
    Icon = "heart",
    Value = false,
    Callback = function(state)
        healthBillboardEnabled = state
        if state then
            enableHealthBillboards()
        else
            disableHealthBillboards()
        end
    end
})

Tabs.PlayerEspTab:Toggle({
    Title = "Player ESP",
    Icon = "users",
    Value = false,
    Callback = function(state)
        if state then
            enablePlayerESP()
        else
            disablePlayerESP()
        end
    end
})

Tabs.PlayerEspTab:Toggle({
    Title = "Show Player Names",
    Icon = "user-check",
    Value = true,
    Callback = function(state)
        ESP_SETTINGS.ShowNames = state
        WindUI:Notify({
            Title = "‚úÖ Player Names",
            Content = state and "Showing player names" or "Hiding player names",
            Duration = 3
        })
    end
})

Tabs.PlayerEspTab:Toggle({
    Title = "Show Player Distance",
    Icon = "ruler",
    Value = true,
    Callback = function(state)
        ESP_SETTINGS.ShowDistance = state
        WindUI:Notify({
            Title = "‚úÖ Player Distance",
            Content = state and "Showing player distance" or "Hiding player distance",
            Duration = 3
        })
    end
})

Tabs.PlayerEspTab:Toggle({
    Title = "Show Player Health",
    Icon = "heart-pulse",
    Value = true,
    Callback = function(state)
        ESP_SETTINGS.ShowHealth = state
        WindUI:Notify({
            Title = "‚úÖ Player Health",
            Content = state and "Showing player health" or "Hiding player health",
            Duration = 3
        })
    end
})

Tabs.PlayerEspTab:Toggle({
    Title = "Show Health Bar",
    Icon = "activity",
    Value = true,
    Callback = function(state)
        ESP_SETTINGS.HealthBarEnabled = state
        WindUI:Notify({
            Title = "‚úÖ Health Bar",
            Content = state and "Showing health bars" or "Hiding health bars",
            Duration = 3
        })
    end
})

Tabs.PlayerEspTab:Slider({
    Title = "ESP Max Distance",
    Value = { Min = 100, Max = 2000, Default = 1000 },
    Callback = function(value)
        ESP_SETTINGS.MaxDistance = value
        WindUI:Notify({
            Title = "üìè ESP Max Distance",
            Content = "Set to " .. value .. " studs",
            Duration = 3
        })
    end
})

Tabs.PlayerEspTab:Slider({
    Title = "ESP Text Size",
    Value = { Min = 8, Max = 24, Default = 14 },
    Callback = function(value)
        ESP_SETTINGS.TextSize = value
        WindUI:Notify({
            Title = "üìè ESP Text Size",
            Content = "Set to " .. value,
            Duration = 3
        })
    end
})

Tabs.PlayerEspTab:Button({
    Title = "Clear Player ESP",
    Desc = "Removes all active player ESP and health billboards",
    Callback = function()
        disableHealthBillboards()
        disablePlayerESP()
        healthBillboardEnabled = false
        playerESPEnabled = false
        WindUI:Notify({
            Title = "‚úÖ Cleared Player ESP",
            Content = "All player ESP and billboards removed",
            Duration = 3
        })
    end
})

-- === Item ESP Tab ===
Tabs.ItemEspTab = Window:Tab({
    Title = "Item ESP",
    Icon = "package",
    Desc = "ESP for in-game items and entities"
})

-- Item ESP System
local ActiveEspItems = false
local ActiveEspEnemy = false
local ActiveEspChildren = false
local ActiveEspPeltTrader = false
local ActiveDistanceEsp = false

local ITEM_ESP_SETTINGS = {
    ItemColor = Color3.fromRGB(255, 255, 0),
    EnemyColor = Color3.fromRGB(255, 0, 0),
    ChildColor = Color3.fromRGB(0, 255, 0),
    PeltTraderColor = Color3.fromRGB(0, 255, 255),
    TextSize = 12,
    MaxDistance = 1000
}

local function CreateEsp(Char, Color, Text, Parent, offset)
    if not Char or not Parent or not Parent:IsA("BasePart") then return end
    if Char:FindFirstChildOfClass("Highlight") or Parent:FindFirstChild("ESP") then return end

    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.Adornee = Char
    highlight.FillColor = Color
    highlight.FillTransparency = 1
    highlight.OutlineColor = Color
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = Char

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP"
    billboard.Size = UDim2.new(0, 50, 0, 25)
    billboard.AlwaysOnTop = true
    billboard.StudsOffset = Vector3.new(0, offset or 2, 0)
    billboard.MaxDistance = ITEM_ESP_SETTINGS.MaxDistance
    billboard.Adornee = Parent
    billboard.Parent = Parent

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = Text
    label.TextColor3 = Color
    label.TextSize = ITEM_ESP_SETTINGS.TextSize
    label.TextScaled = true
    label.Font = Enum.Font.Gotham
    label.Parent = billboard

    task.spawn(function()
        while highlight.Parent and billboard.Parent and Parent.Parent do
            local camera = workspace.CurrentCamera
            if ActiveDistanceEsp and camera and Parent:IsA("BasePart") then
                local distance = (camera.CFrame.Position - Parent.Position).Magnitude
                label.Text = Text .. " (" .. math.floor(distance + 0.5) .. " m)"
            else
                label.Text = Text
            end
            RunService.Heartbeat:Wait()
        end
        if highlight.Parent then highlight:Destroy() end
        if billboard.Parent then billboard:Destroy() end
    end)
end

local function RemoveEsp(Char, Parent)
    if Char and Char:FindFirstChildOfClass("Highlight") then
        Char:FindFirstChildOfClass("Highlight"):Destroy()
    end
    if Parent and Parent:FindFirstChild("ESP") then
        Parent:FindFirstChild("ESP"):Destroy()
    end
end

local function UpdateItemsEsp()
    if not workspace:FindFirstChild("Items") then return end
    if ActiveEspItems then
        for _, obj in pairs(workspace.Items:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart then
                CreateEsp(obj, ITEM_ESP_SETTINGS.ItemColor, obj.Name, obj.PrimaryPart, 2)
            end
        end
    else
        for _, obj in pairs(workspace.Items:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

local function UpdateEnemiesEsp()
    if not workspace:FindFirstChild("Characters") then return end
    if ActiveEspEnemy then
        for _, obj in pairs(workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               not (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                    obj.Name == "Lost Child3" or obj.Name == "Lost Child4" or
                    obj.Name == "Pelt Trader") and
               not Players:GetPlayerFromCharacter(obj) then
                CreateEsp(obj, ITEM_ESP_SETTINGS.EnemyColor, obj.Name, obj.PrimaryPart, 3)
            end
        end
    else
        for _, obj in pairs(workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               not (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                    obj.Name == "Lost Child3" or obj.Name == "Lost Child4" or
                    obj.Name == "Pelt Trader") and
               not Players:GetPlayerFromCharacter(obj) then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

local function UpdateChildrenEsp()
    if not workspace:FindFirstChild("Characters") then return end
    if ActiveEspChildren then
        for _, obj in pairs(workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                obj.Name == "Lost Child3" or obj.Name == "Lost Child4") then
                CreateEsp(obj, ITEM_ESP_SETTINGS.ChildColor, obj.Name, obj.PrimaryPart, 3)
            end
        end
    else
        for _, obj in pairs(workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                obj.Name == "Lost Child3" or obj.Name == "Lost Child4") then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

local function UpdatePeltTraderEsp()
    if not workspace:FindFirstChild("Characters") then return end
    if ActiveEspPeltTrader then
        for _, obj in pairs(workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and obj.Name == "Pelt Trader" then
                CreateEsp(obj, ITEM_ESP_SETTINGS.PeltTraderColor, obj.Name, obj.PrimaryPart, 3)
            end
        end
    else
        for _, obj in pairs(workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and obj.Name == "Pelt Trader" then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

local function setupItemEspConnections()
    if workspace:FindFirstChild("Items") then
        workspace.Items.ChildAdded:Connect(function(child)
            if ActiveEspItems and child:IsA("Model") and child.PrimaryPart then
                CreateEsp(child, ITEM_ESP_SETTINGS.ItemColor, child.Name, child.PrimaryPart, 2)
            end
        end)
        workspace.Items.ChildRemoved:Connect(function(child)
            if child:IsA("Model") and child.PrimaryPart then
                RemoveEsp(child, child.PrimaryPart)
            end
        end)
    end

    if workspace:FindFirstChild("Characters") then
        workspace.Characters.ChildAdded:Connect(function(child)
            if child:IsA("Model") and child.PrimaryPart then
                if ActiveEspEnemy and
                   not (child.Name == "Lost Child" or child.Name == "Lost Child2" or
                        child.Name == "Lost Child3" or child.Name == "Lost Child4" or
                        child.Name == "Pelt Trader") and
                   not Players:GetPlayerFromCharacter(child) then
                    CreateEsp(child, ITEM_ESP_SETTINGS.EnemyColor, child.Name, child.PrimaryPart, 3)
                elseif ActiveEspChildren and
                   (child.Name == "Lost Child" or child.Name == "Lost Child2" or
                    child.Name == "Lost Child3" or child.Name == "Lost Child4") then
                    CreateEsp(child, ITEM_ESP_SETTINGS.ChildColor, child.Name, child.PrimaryPart, 3)
                elseif ActiveEspPeltTrader and child.Name == "Pelt Trader" then
                    CreateEsp(child, ITEM_ESP_SETTINGS.PeltTraderColor, child.Name, child.PrimaryPart, 3)
                end
            end
        end)
        workspace.Characters.ChildRemoved:Connect(function(child)
            if child:IsA("Model") and child.PrimaryPart then
                RemoveEsp(child, child.PrimaryPart)
            end
        end)
    end
end

-- Item ESP Controls
Tabs.ItemEspTab:Paragraph({
    Title = "Item ESP System",
    Desc = "ESP for in-game items and entities",
    Image = "package",
    Color = "Yellow"
})

Tabs.ItemEspTab:Toggle({
    Title = "ESP Items",
    Icon = "package",
    Value = false,
    Callback = function(state)
        ActiveEspItems = state
        UpdateItemsEsp()
        WindUI:Notify({
            Title = "‚úÖ ESP Items",
            Content = state and "Enabled for items" or "Disabled for items",
            Duration = 3
        })
    end
})

Tabs.ItemEspTab:Toggle({
    Title = "ESP Enemies",
    Icon = "skull",
    Value = false,
    Callback = function(state)
        ActiveEspEnemy = state
        UpdateEnemiesEsp()
        WindUI:Notify({
            Title = "‚úÖ ESP Enemies",
            Content = state and "Enabled for enemies" or "Disabled for enemies",
            Duration = 3
        })
    end
})

Tabs.ItemEspTab:Toggle({
    Title = "ESP Children",
    Icon = "baby",
    Value = false,
    Callback = function(state)
        ActiveEspChildren = state
        UpdateChildrenEsp()
        WindUI:Notify({
            Title = "‚úÖ ESP Children",
            Content = state and "Enabled for Lost Children" or "Disabled for Lost Children",
            Duration = 3
        })
    end
})

Tabs.ItemEspTab:Toggle({
    Title = "ESP Pelt Trader",
    Icon = "user",
    Value = false,
    Callback = function(state)
        ActiveEspPeltTrader = state
        UpdatePeltTraderEsp()
        WindUI:Notify({
            Title = "‚úÖ ESP Pelt Trader",
            Content = state and "Enabled for Pelt Trader" or "Disabled for Pelt Trader",
            Duration = 3
        })
    end
})

Tabs.ItemEspTab:Toggle({
    Title = "Show Distance in ESP",
    Icon = "ruler",
    Value = false,
    Callback = function(state)
        ActiveDistanceEsp = state
        if ActiveEspItems then UpdateItemsEsp() end
        if ActiveEspEnemy then UpdateEnemiesEsp() end
        if ActiveEspChildren then UpdateChildrenEsp() end
        if ActiveEspPeltTrader then UpdatePeltTraderEsp() end
        WindUI:Notify({
            Title = "‚úÖ Distance Display",
            Content = state and "Showing distances" or "Hiding distances",
            Duration = 3
        })
    end
})

Tabs.ItemEspTab:Slider({
    Title = "ESP Max Distance",
    Value = { Min = 100, Max = 2000, Default = 1000 },
    Callback = function(value)
        ITEM_ESP_SETTINGS.MaxDistance = value
        WindUI:Notify({
            Title = "üìè ESP Max Distance",
            Content = "Set to " .. value .. " studs",
            Duration = 3
        })
    end
})

Tabs.ItemEspTab:Slider({
    Title = "ESP Text Size",
    Value = { Min = 8, Max = 24, Default = 12 },
    Callback = function(value)
        ITEM_ESP_SETTINGS.TextSize = value
        WindUI:Notify({
            Title = "üìè ESP Text Size",
            Content = "Set to " .. value,
            Duration = 3
        })
    end
})

Tabs.ItemEspTab:Dropdown({
    Title = "ESP Color Theme",
    Values = {"Default", "Bright", "Dark", "Neon"},
    Value = "Default",
    Callback = function(value)
        if value == "Bright" then
            ITEM_ESP_SETTINGS.ItemColor = Color3.fromRGB(255, 255, 100)
            ITEM_ESP_SETTINGS.EnemyColor = Color3.fromRGB(255, 100, 100)
            ITEM_ESP_SETTINGS.ChildColor = Color3.fromRGB(100, 255, 100)
            ITEM_ESP_SETTINGS.PeltTraderColor = Color3.fromRGB(100, 255, 255)
        elseif value == "Dark" then
            ITEM_ESP_SETTINGS.ItemColor = Color3.fromRGB(150, 150, 0)
            ITEM_ESP_SETTINGS.EnemyColor = Color3.fromRGB(150, 0, 0)
            ITEM_ESP_SETTINGS.ChildColor = Color3.fromRGB(0, 150, 0)
            ITEM_ESP_SETTINGS.PeltTraderColor = Color3.fromRGB(0, 150, 150)
        elseif value == "Neon" then
            ITEM_ESP_SETTINGS.ItemColor = Color3.fromRGB(255, 255, 0)
            ITEM_ESP_SETTINGS.EnemyColor = Color3.fromRGB(255, 0, 255)
            ITEM_ESP_SETTINGS.ChildColor = Color3.fromRGB(0, 255, 255)
            ITEM_ESP_SETTINGS.PeltTraderColor = Color3.fromRGB(255, 0, 255)
        else -- Default
            ITEM_ESP_SETTINGS.ItemColor = Color3.fromRGB(255, 255, 0)
            ITEM_ESP_SETTINGS.EnemyColor = Color3.fromRGB(255, 0, 0)
            ITEM_ESP_SETTINGS.ChildColor = Color3.fromRGB(0, 255, 0)
            ITEM_ESP_SETTINGS.PeltTraderColor = Color3.fromRGB(0, 255, 255)
        end
        if ActiveEspItems then UpdateItemsEsp() end
        if ActiveEspEnemy then UpdateEnemiesEsp() end
        if ActiveEspChildren then UpdateChildrenEsp() end
        if ActiveEspPeltTrader then UpdatePeltTraderEsp() end
        WindUI:Notify({
            Title = "üé® ESP Color Theme",
            Content = "Set to " .. value,
            Duration = 3
        })
    end
})

Tabs.ItemEspTab:Button({
    Title = "Clear All ESP",
    Desc = "Removes all active item and entity ESP",
    Callback = function()
        ActiveEspItems = false
        ActiveEspEnemy = false
        ActiveEspChildren = false
        ActiveEspPeltTrader = false
        UpdateItemsEsp()
        UpdateEnemiesEsp()
        UpdateChildrenEsp()
        UpdatePeltTraderEsp()
        WindUI:Notify({
            Title = "‚úÖ Cleared Item ESP",
            Content = "All item and entity ESP removed",
            Duration = 3
        })
    end
})

setupItemEspConnections()

-- POV Control Tab
Tabs.PovTab = Window:Tab({
    Title = "POV Control",
    Icon = "eye",
    Desc = "Control player point of view, fog, brightness, and more"
})

-- Services
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

-- Variables for POV controls
local noFogEnabled = false
local fullBrightEnabled = false
local nightVisionEnabled = false
local grayscaleEnabled = false
local povLockEnabled = false

local originalFogEnd = Lighting.FogEnd
local originalBrightness = Lighting.Brightness
local originalAmbient = Lighting.Ambient
local originalGlobalShadows = Lighting.GlobalShadows

local nightVisionEffect
local grayscaleEffect

-- Function to toggle no fog
local function toggleNoFog(state)
    noFogEnabled = state
    if state then
        Lighting.FogEnd = 100000
        WindUI:Notify({
            Title = "‚úÖ No Fog Enabled",
            Content = "Fog has been disabled",
            Duration = 3
        })
    else
        Lighting.FogEnd = originalFogEnd
        WindUI:Notify({
            Title = "‚ùå No Fog Disabled",
            Content = "Fog has been restored",
            Duration = 3
        })
    end
end

-- Function to toggle full bright
local function toggleFullBright(state)
    fullBrightEnabled = state
    if state then
        Lighting.Brightness = 2
        Lighting.Ambient = Color3.new(1, 1, 1)
        Lighting.GlobalShadows = false
        WindUI:Notify({
            Title = "‚úÖ Full Bright Enabled",
            Content = "Full brightness activated",
            Duration = 3
        })
    else
        Lighting.Brightness = originalBrightness
        Lighting.Ambient = originalAmbient
        Lighting.GlobalShadows = originalGlobalShadows
        WindUI:Notify({
            Title = "‚ùå Full Bright Disabled",
            Content = "Original lighting restored",
            Duration = 3
        })
    end
end

-- Function to toggle night vision
local function toggleNightVision(state)
    nightVisionEnabled = state
    if not nightVisionEffect then
        nightVisionEffect = Instance.new("ColorCorrectionEffect")
        nightVisionEffect.Name = "NightVisionEffect"
        nightVisionEffect.Parent = workspace.CurrentCamera
    end
    if state then
        nightVisionEffect.Brightness = 0.1
        nightVisionEffect.Contrast = 0.5
        nightVisionEffect.Saturation = -0.2
        nightVisionEffect.TintColor = Color3.fromRGB(0, 255, 0)
        nightVisionEffect.Enabled = true
        WindUI:Notify({
            Title = "‚úÖ Night Vision Enabled",
            Content = "Player POV now in night vision mode",
            Duration = 3
        })
    else
        nightVisionEffect.Enabled = false
        WindUI:Notify({
            Title = "‚ùå Night Vision Disabled",
            Content = "Normal POV restored",
            Duration = 3
        })
    end
end

-- Function to toggle grayscale POV
local function toggleGrayscale(state)
    grayscaleEnabled = state
    if not grayscaleEffect then
        grayscaleEffect = Instance.new("ColorCorrectionEffect")
        grayscaleEffect.Name = "GrayscaleEffect"
        grayscaleEffect.Parent = workspace.CurrentCamera
    end
    if state then
        grayscaleEffect.Saturation = -1
        grayscaleEffect.Enabled = true
        WindUI:Notify({
            Title = "‚úÖ Grayscale Enabled",
            Content = "Player POV now in grayscale",
            Duration = 3
        })
    else
        grayscaleEffect.Enabled = false
        WindUI:Notify({
            Title = "‚ùå Grayscale Disabled",
            Content = "Color POV restored",
            Duration = 3
        })
    end
end

-- Function to toggle POV lock (freezes camera rotation)
local function togglePovLock(state)
    povLockEnabled = state
    if state then
        local connection
        connection = RunService.RenderStepped:Connect(function()
            if povLockEnabled then
                workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame * CFrame.Angles(0, 0, 0) -- Lock rotation
            else
                connection:Disconnect()
            end
        end)
        WindUI:Notify({
            Title = "‚úÖ POV Lock Enabled",
            Content = "Player POV rotation locked",
            Duration = 3
        })
    else
        WindUI:Notify({
            Title = "‚ùå POV Lock Disabled",
            Content = "Player POV rotation unlocked",
            Duration = 3
        })
    end
end

-- Camera FOV Slider
Tabs.PovTab:Slider({
    Title = "Camera FOV",
    Value = { Min = 70, Max = 120, Default = 70 },
    Callback = function(value)
        workspace.CurrentCamera.FieldOfView = value
        WindUI:Notify({
            Title = "üì∏ Camera FOV",
            Content = "Set to " .. value,
            Duration = 3
        })
    end
})

-- No Fog Toggle
Tabs.PovTab:Toggle({
    Title = "No Fog",
    Icon = "cloud-off",
    Value = false,
    Callback = function(state)
        toggleNoFog(state)
    end
})

-- Full Bright Toggle
Tabs.PovTab:Toggle({
    Title = "Full Bright",
    Icon = "sun",
    Value = false,
    Callback = function(state)
        toggleFullBright(state)
    end
})

-- Night Vision Toggle
Tabs.PovTab:Toggle({
    Title = "Night Vision",
    Icon = "moon",
    Value = false,
    Callback = function(state)
        toggleNightVision(state)
    end
})

-- Grayscale Toggle
Tabs.PovTab:Toggle({
    Title = "Grayscale POV",
    Icon = "contrast",
    Value = false,
    Callback = function(state)
        toggleGrayscale(state)
    end
})

-- POV Lock Toggle
Tabs.PovTab:Toggle({
    Title = "Lock POV",
    Icon = "lock",
    Value = false,
    Callback = function(state)
        togglePovLock(state)
    end
})

print("üî≠ POV Control Tab loaded with features!")

print("‚úÖ ESP Tabs loaded!")
print("‚òÅÔ∏è Teleport System loaded!")
print("All components loaded!")
