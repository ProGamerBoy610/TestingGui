local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")

-- Gradient text function (used in popup)
local function gradient(text, startColor, endColor)
    local result = ""
    for i = 1, #text do
        local t = (i - 1) / math.max(#text - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)
        result = result .. string.format('<font color="rgb(%d, %d, %d)">%s</font>', r, g, b, text:sub(i, i))
    end
    return result
end

-- Popup before loading
local Confirmed = false
WindUI:Popup({
    Title = "Confirmation",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Content = "Fryzer Hub " .. gradient("FH", Color3.fromHex("#00FF87"), Color3.fromHex("#60EFFF")),
    Buttons = {
        {
            Title = "Cancel",
            Variant = "Secondary",
        },
        {
            Title = "Continue",
            Icon = "arrow-right",
            Callback = function() Confirmed = true end,
            Variant = "Primary",
        }
    }
})
repeat task.wait() until Confirmed

-- Window creation with Key System
local Window = WindUI:CreateWindow({
    Title = "Fryzer Hub",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Author = "99 nights in forest",
    Folder = "YourHub",
    Size = UDim2.fromOffset(580, 360),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    ScrollBarEnabled = true,
    KeySystem = {
        Key = {"1234", "CM"},
        Note = "Enter the key to proceed.",
        URL = "https://your-key-link.com",
        SaveKey = false,
    },
    
    User = {
        Enabled = true,
        Anonymous = false,
        Username = LocalPlayer.DisplayName,
        UserId = LocalPlayer.UserId,
        Callback = function()
            print("User icon clicked:", LocalPlayer.Name)
        end
    }
})

-- UI open button
Window:EditOpenButton({
    Title = "Open UI",
    Icon = "monitor",
    CornerRadius = UDim.new(0, 16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    Draggable = true,
})

-- Main Tab
local PlayerTab = Window:Tab({ Title = "Player", Icon = "user" })

-- Welcome Paragraph
PlayerTab:Paragraph({
    Title = "Welcome to Fryzer Hub!",
    Content = "Hello " .. LocalPlayer.DisplayName .. "! You're running WindUI successfully."
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Default speed
local defaultSpeed = 16

-- Toggle for WalkSpeed
PlayerTab:Toggle({
    Title = "WalkSpeed", 
    Value = false,
    Callback = function(state)
        if state then
            -- Set to slider value when enabled
            LocalPlayer.Character.Humanoid.WalkSpeed = _G.CurrentWalkSpeed or defaultSpeed
        else
            -- Reset to Roblox default when disabled
            LocalPlayer.Character.Humanoid.WalkSpeed = defaultSpeed
        end
        print("WalkSpeed enabled:", state)
    end
})

-- Slider to adjust WalkSpeed
PlayerTab:Slider({
    Title = "Speed Changer",
    Value = {
        Min = 16,
        Max = 100,
        Default = 16
    },
    Callback = function(val)
        _G.CurrentWalkSpeed = val
        -- If toggle is enabled, update immediately
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.WalkSpeed = val
        end
        print("WalkSpeed set to:", val)
    end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Default jump height
local defaultJumpHeight = 7.2 -- Roblox default JumpHeight

-- Toggle for Jump Height
PlayerTab:Toggle({
    Title = "Enable Jump Power", 
    Value = false,
    Callback = function(state)
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            if state then
                humanoid.UseJumpPower = false -- Ensure JumpHeight is used
                humanoid.JumpHeight = _G.CurrentJumpHeight or defaultJumpHeight
            else
                humanoid.JumpHeight = defaultJumpHeight
            end
        end
        print("Jump Height enabled:", state)
    end
})

-- Slider to adjust Jump Height
PlayerTab:Slider({
    Title = "Jump Power",
    Value = {
        Min = 7.2,
        Max = 50,
        Default = 7.2
    },
    Callback = function(val)
        _G.CurrentJumpHeight = val
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.JumpHeight = val
        end
        print("Jump Height set to:", val)
    end
})


local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local IYMouse = Players.LocalPlayer:GetMouse()
local FLYING = false
local QEfly = true
local iyflyspeed = 1
local vehicleflyspeed = 1
local ActivateFly = false

local function sFLY(vfly)
    repeat wait() until Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart") and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    repeat wait() until IYMouse
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end

    local T = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0

    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro')
        local BV = Instance.new('BodyVelocity')
        BG.P = 9e4
        BG.Parent = T
        BV.Parent = T
        BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.CFrame = T.CFrame
        BV.Velocity = Vector3.new(0, 0, 0)
        BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            repeat wait()
                if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                    Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = 50
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.Velocity = Vector3.new(0, 0, 0)
                end
                BG.CFrame = workspace.CurrentCamera.CoordinateFrame
            until not FLYING
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:Destroy()
            BV:Destroy()
            if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
            end
        end)
    end
    flyKeyDown = IYMouse.KeyDown:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 's' then
            CONTROL.B = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'a' then
            CONTROL.L = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'd' then 
            CONTROL.R = (vfly and vehicleflyspeed or iyflyspeed)
        elseif QEfly and KEY:lower() == 'e' then
            CONTROL.Q = (vfly and vehicleflyspeed or iyflyspeed)*2
        elseif QEfly and KEY:lower() == 'q' then
            CONTROL.E = -(vfly and vehicleflyspeed or iyflyspeed)*2
        end
        pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
    end)
    flyKeyUp = IYMouse.KeyUp:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = 0
        elseif KEY:lower() == 's' then
            CONTROL.B = 0
        elseif KEY:lower() == 'a' then
            CONTROL.L = 0
        elseif KEY:lower() == 'd' then
            CONTROL.R = 0
        elseif KEY:lower() == 'e' then
            CONTROL.Q = 0
        elseif KEY:lower() == 'q' then
            CONTROL.E = 0
        end
    end)
    FLY()
end

local function NOFLY()
    FLYING = false
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end
    if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
        Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
    end
    pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

local velocityHandlerName = "BodyVelocity"
local gyroHandlerName = "BodyGyro"
local mfly1
local mfly2

local function UnMobileFly()
    pcall(function()
        FLYING = false
        local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        root:FindFirstChild(velocityHandlerName):Destroy()
        root:FindFirstChild(gyroHandlerName):Destroy()
        Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
        mfly1:Disconnect()
        mfly2:Disconnect()
    end)
end

local function MobileFly()
    UnMobileFly()
    FLYING = true

    local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local camera = workspace.CurrentCamera
    local v3none = Vector3.new()
    local v3zero = Vector3.new(0, 0, 0)
    local v3inf = Vector3.new(9e9, 9e9, 9e9)

    local controlModule = require(Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    local bv = Instance.new("BodyVelocity")
    bv.Name = velocityHandlerName
    bv.Parent = root
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = gyroHandlerName
    bg.Parent = root
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50

    mfly1 = Players.LocalPlayer.CharacterAdded:Connect(function()
        local bv = Instance.new("BodyVelocity")
        bv.Name = velocityHandlerName
        bv.Parent = root
        bv.MaxForce = v3zero
        bv.Velocity = v3zero

        local bg = Instance.new("BodyGyro")
        bg.Name = gyroHandlerName
        bg.Parent = root
        bg.MaxTorque = v3inf
        bg.P = 1000
        bg.D = 50
    end)

    mfly2 = RunService.RenderStepped:Connect(function()
        root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        camera = workspace.CurrentCamera
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
            local humanoid = Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
            local VelocityHandler = root:FindFirstChild(velocityHandlerName)
            local GyroHandler = root:FindFirstChild(gyroHandlerName)

            VelocityHandler.MaxForce = v3inf
            GyroHandler.MaxTorque = v3inf
            humanoid.PlatformStand = true
            GyroHandler.CFrame = camera.CoordinateFrame
            VelocityHandler.Velocity = v3none

            local direction = controlModule:GetMoveVector()
            if direction.X > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.X < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.Z > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
            if direction.Z < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
        end
    end)
end

-- Fly Speed Slider
PlayerTab:Slider({
    Title = "Fly Speed",
    Value = {
        Min = 0.1,
        Max = 10,
        Default = 1
    },
    Callback = function(val)
        iyflyspeed = val
    end
})

-- Fly Toggle
PlayerTab:Toggle({
    Title = "Fly", 
    Value = false,
    Callback = function(state)
        ActivateFly = state
        task.spawn(function()
            if not FLYING and ActivateFly then
                if UserInputService.TouchEnabled then
                    MobileFly()
                else
                    NOFLY()
                    wait()
                    sFLY()
                end
            elseif FLYING and not ActivateFly then
                if UserInputService.TouchEnabled then
                    UnMobileFly()
                else
                    NOFLY()
                end
            end
        end)
    end
})

-- F key toggle for fly (optional - you can remove this if not needed)
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.F then
        if not FLYING and ActivateFly then
            if UserInputService.TouchEnabled then
                MobileFly()
            else
                NOFLY()
                wait()
                sFLY()
            end
        elseif FLYING and ActivateFly then
            if UserInputService.TouchEnabled then
                UnMobileFly()
            else
                NOFLY()
            end
        end
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local noclipConnection
local noclipEnabled = false

PlayerTab:Toggle({
    Title = "Noclip", 
    Value = false,
    Callback = function(state)
        noclipEnabled = state

        if state then
            -- Start noclip
            noclipConnection = RunService.Stepped:Connect(function()
                local character = LocalPlayer.Character
                if character then
                    for _, part in pairs(character:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            -- Stop noclip and restore collisions
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
            local character = LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end

        print("Noclip", state)
    end
})

local esptpTab = Window:Tab({ Title = "ESP & TP", Icon = "send" })

-- ESP State Variables
local ActiveEspItems = false
local ActiveEspEnemy = false
local ActiveEspChildren = false
local ActiveEspPeltTrader = false
local ActiveDistanceEsp = false

-- ESP Creation Function
local function CreateEsp(Char, Color, Text, Parent, number)
    if not Char or not Parent or not Parent:IsA("BasePart") then return end
    if Char:FindFirstChildOfClass("Highlight") or Parent:FindFirstChild("ESP") then return end

    -- Create Highlight
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.Adornee = Char
    highlight.FillColor = Color
    highlight.FillTransparency = 1
    highlight.OutlineColor = Color
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = Char

    -- Create Billboard
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP"
    billboard.Size = UDim2.new(0, 50, 0, 25)
    billboard.AlwaysOnTop = true
    billboard.StudsOffset = Vector3.new(0, number or 2, 0)
    billboard.Adornee = Parent
    billboard.Parent = Parent

    -- Create Label
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = Text
    label.TextColor3 = Color
    label.TextScaled = true
    label.Parent = billboard

    -- Distance Update Task
    task.spawn(function()
        local RunService = game:GetService("RunService")
        local Workspace = game:GetService("Workspace")
        while highlight.Parent and billboard.Parent and Parent.Parent do
            local camera = Workspace.CurrentCamera
            if ActiveDistanceEsp and camera and Parent:IsA("BasePart") then
                local distance = (camera.CFrame.Position - Parent.Position).Magnitude
                label.Text = Text .. " (" .. math.floor(distance + 0.5) .. " m)"
            else
                label.Text = Text
            end
            RunService.Heartbeat:Wait()
        end
        -- Cleanup
        if highlight.Parent then highlight:Destroy() end
        if billboard.Parent then billboard:Destroy() end
    end)
end

-- ESP Removal Function
local function RemoveEsp(Char, Parent)
    if Char and Char:FindFirstChildOfClass("Highlight") then
        Char:FindFirstChildOfClass("Highlight"):Destroy()
    end
    if Parent and Parent:FindFirstChild("ESP") then
        Parent:FindFirstChild("ESP"):Destroy()
    end
end

-- Function to Update ESP for Items
local function UpdateItemsEsp()
    if ActiveEspItems then
        for _, obj in pairs(game.Workspace.Items:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart then
                CreateEsp(obj, Color3.fromRGB(255, 255, 0), obj.Name, obj.PrimaryPart, 2)
            end
        end
    else
        for _, obj in pairs(game.Workspace.Items:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

-- Function to Update ESP for Enemies
local function UpdateEnemiesEsp()
    if ActiveEspEnemy then
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               not (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                    obj.Name == "Lost Child3" or obj.Name == "Lost Child4" or
                    obj.Name == "Pelt Trader") then
                CreateEsp(obj, Color3.fromRGB(255, 0, 0), obj.Name, obj.PrimaryPart, 3)
            end
        end
    else
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               not (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                    obj.Name == "Lost Child3" or obj.Name == "Lost Child4" or
                    obj.Name == "Pelt Trader") then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

-- Function to Update ESP for Children
local function UpdateChildrenEsp()
    if ActiveEspChildren then
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                obj.Name == "Lost Child3" or obj.Name == "Lost Child4") then
                CreateEsp(obj, Color3.fromRGB(0, 255, 0), obj.Name, obj.PrimaryPart, 3)
            end
        end
    else
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                obj.Name == "Lost Child3" or obj.Name == "Lost Child4") then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

-- Function to Update ESP for Pelt Trader
local function UpdatePeltTraderEsp()
    if ActiveEspPeltTrader then
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and obj.Name == "Pelt Trader" then
                CreateEsp(obj, Color3.fromRGB(0, 255, 255), obj.Name, obj.PrimaryPart, 3)
            end
        end
    else
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and obj.Name == "Pelt Trader" then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

-- ESP Dropdown (Multi-select)
esptpTab:Dropdown({
    Title = "ESP Types",
    Values = {"Items", "Enemies", "Children", "Pelt Trader"},
    Value = {}, -- Empty initial selection
    Multi = true,
    AllowNone = true,
    Flag = "EspTypes",
    Callback = function(values)
        -- Reset all ESP states
        ActiveEspItems = false
        ActiveEspEnemy = false
        ActiveEspChildren = false
        ActiveEspPeltTrader = false

        -- Enable selected ESP types
        for _, espType in pairs(values) do
            if espType == "Items" then
                ActiveEspItems = true
            elseif espType == "Enemies" then
                ActiveEspEnemy = true
            elseif espType == "Children" then
                ActiveEspChildren = true
            elseif espType == "Pelt Trader" then
                ActiveEspPeltTrader = true
            end
        end

        -- Update ESP immediately
        UpdateItemsEsp()
        UpdateEnemiesEsp()
        UpdateChildrenEsp()
        UpdatePeltTraderEsp()

        print("ESP Types Selected:", game:GetService("HttpService"):JSONEncode(values))
    end
})

-- ESP Distance Toggle
esptpTab:Toggle({
    Title = "Show Distance in ESP",
    Value = false,
    Flag = "EspDistance",
    Callback = function(state)
        ActiveDistanceEsp = state
        -- Update all active ESPs to reflect distance change
        if ActiveEspItems then UpdateItemsEsp() end
        if ActiveEspEnemy then UpdateEnemiesEsp() end
        if ActiveEspChildren then UpdateChildrenEsp() end
        if ActiveEspPeltTrader then UpdatePeltTraderEsp() end
        print("Show Distance in ESP:", state)
    end
})

-- Event-driven ESP updates
local itemsConnection, charactersConnection

local function setupEspConnections()
    if itemsConnection then itemsConnection:Disconnect() end
    if charactersConnection then charactersConnection:Disconnect() end

    itemsConnection = game.Workspace.Items.ChildAdded:Connect(function(child)
        if ActiveEspItems and child:IsA("Model") and child.PrimaryPart then
            CreateEsp(child, Color3.fromRGB(255, 255, 0), child.Name, child.PrimaryPart, 2)
        end
    end)

    game.Workspace.Items.ChildRemoved:Connect(function(child)
        if child:IsA("Model") and child.PrimaryPart then
            RemoveEsp(child, child.PrimaryPart)
        end
    end)

    charactersConnection = game.Workspace.Characters.ChildAdded:Connect(function(child)
        if child:IsA("Model") and child.PrimaryPart then
            if ActiveEspEnemy and
               not (child.Name == "Lost Child" or child.Name == "Lost Child2" or
                    child.Name == "Lost Child3" or child.Name == "Lost Child4" or
                    child.Name == "Pelt Trader") then
                CreateEsp(child, Color3.fromRGB(255, 0, 0), child.Name, child.PrimaryPart, 3)
            elseif ActiveEspChildren and
               (child.Name == "Lost Child" or child.Name == "Lost Child2" or
                child.Name == "Lost Child3" or child.Name == "Lost Child4") then
                CreateEsp(child, Color3.fromRGB(0, 255, 0), child.Name, child.PrimaryPart, 3)
            elseif ActiveEspPeltTrader and child.Name == "Pelt Trader" then
                CreateEsp(child, Color3.fromRGB(0, 255, 255), child.Name, child.PrimaryPart, 3)
            end
        end
    end)

    game.Workspace.Characters.ChildRemoved:Connect(function(child)
        if child:IsA("Model") and child.PrimaryPart then
            RemoveEsp(child, child.PrimaryPart)
        end
    end)
end

-- Initialize ESP connections
setupEspConnections()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

esptpTab:Button({
    Title = "Tp to campfire",
    Desc = "Teleports you to the campfire",
    Callback = function()
        local targetPosition = Vector3.new(0.2976149320602417, 6.346785545349121, -0.043002475053071976)
        
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
            
            WindUI:Notify({
                Title = "Teleport",
                Content = "Teleported successfully!",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "Teleport Failed",
                Content = "Somthing went wrong!",
                Duration = 1
            })
        end
    end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local ItemsFolder = workspace:FindFirstChild("Items")

if not ItemsFolder then
    warn("Items folder not found!")
    return
end

-- UI State
local uniqueModelNames = {}
local modelMap = {}  -- Stores list of models by name
local selectedModelName = nil
local dropdown = nil

-- Refresh model list
local function refreshModelList()
    uniqueModelNames = {}
    modelMap = {}

    for _, item in pairs(ItemsFolder:GetDescendants()) do
        if item:IsA("Model") then
            local name = item.Name
            if not modelMap[name] then
                modelMap[name] = {}
                table.insert(uniqueModelNames, name)
            end
            table.insert(modelMap[name], item)
        end
    end

    if dropdown then
        dropdown:SetValues(uniqueModelNames)
    end
end

-- Run refresh every 5 seconds
task.spawn(function()
    while true do
        refreshModelList()
        task.wait(2)
    end
end)

-- Initial load
refreshModelList()

-- Create Dropdown
dropdown = esptpTab:Dropdown({
    Title = "Select Item",
    Values = uniqueModelNames,
    Value = uniqueModelNames[1] or "None",
    Multi = false,
    AllowNone = false,
    Callback = function(selected)
        selectedModelName = selected
        print("Selected:", selected)
    end
})

-- Find closest model
local function getClosestModel(modelList)
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp or not modelList then return nil end

    local closest, minDist = nil, math.huge
    for _, model in pairs(modelList) do
        local primary = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
        if primary then
            local dist = (hrp.Position - primary.Position).Magnitude
            if dist < minDist then
                minDist = dist
                closest = primary
            end
        end
    end
    return closest
end

-- Teleport Button
esptpTab:Button({
    Title = "Teleport to Item",
    Desc = "Teleport to closest model of selected name",
    Callback = function()
        if not selectedModelName or not modelMap[selectedModelName] then
            warn("No model selected.")
            return
        end

        local closestPart = getClosestModel(modelMap[selectedModelName])
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

        if closestPart and hrp then
            hrp.CFrame = closestPart.CFrame + Vector3.new(0, 5, 0)
            WindUI:Notify({
                Title = "Teleported!",
                Content = "Teleported to nearest: " .. selectedModelName,
                Duration = 3
            })
        else
            warn("Could not find valid part to teleport.")
        end
    end
})

-- Window close callback
Window:OnClose(function()
    print("Window closed.")
end)
