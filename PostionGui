-- Forge Auto Farm Script with Wind UI - Enhanced System

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
WindUI:SetNotificationLower(true)
-- Add Custom Blue Theme
WindUI:AddTheme({
    Name = "Blue Theme",
    Accent = Color3.fromRGB(37, 99, 235),
    Dialog = Color3.fromRGB(15, 23, 42),
    Outline = Color3.fromRGB(59, 130, 246),
    Text = Color3.fromRGB(248, 250, 252),
    Placeholder = Color3.fromRGB(100, 116, 139),
    Background = Color3.fromRGB(15, 23, 42),
    Button = Color3.fromRGB(30, 58, 138),
    Icon = Color3.fromRGB(147, 197, 253)
})

-- Create Main Window
local Window = WindUI:CreateWindow({
    Title = "Fryzer Hub",
    Author = "Join Discord",
    Folder = "FryzerHub",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Blue Theme",
    Resizable = true,
    SideBarWidth = 200,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = false,
    ScrollBarEnabled = true,
})

-- Edit Open Button
Window:EditOpenButton({
    Title = "Fryzer Hub",
    Icon = "",
    CornerRadius = UDim.new(0, 16),
    StrokeThickness = 2,
    Color = ColorSequence.new(
        Color3.fromHex("#1e3a8a"),
        Color3.fromHex("#3b82f6")
    ),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

-- Add Version Tag
Window:Tag({
    Title = "v4.8",
    Color = Color3.fromHex("#3b82f6"),
    Radius = 8,
})
Window:Tag({
    Title = "The Forge",
    Color = Color3.fromHex("#fa0000"),
    Radius = 8,
})

-- ==================== PLAYER INFORMATION SECTION ====================

local InfoTab = Window:Tab({
    Title = "Info",
    Icon = "info",
    Locked = false,
})

InfoTab:Select()

local Sectiontest = InfoTab:Section({
    Title = "Player Information Dashboard",
    Icon = "user-check",
})

InfoTab:Paragraph({
    Title = "Player Information Dashboard",
    Desc = "Complete player details, game information, and community access",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Player = Players.LocalPlayer
local PlayerName = Player.DisplayName ~= "" and Player.DisplayName or Player.Name
local AccountAge = Player.AccountAge
local GameName = "Unknown Game"
pcall(function()
    GameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
end)

InfoTab:Paragraph({
    Title = "üë§ " .. PlayerName,
    Desc = string.format(
        "üè∑Ô∏è Username: @%s\nüéÇ Account Age: %d days\nüÜî User ID: %d\nüéÆ Current Game: %s\nüë• Server: %d/%d players\nüìç Region: %s",
        Player.Name, AccountAge, Player.UserId, GameName,
        #Players:GetPlayers(), Players.MaxPlayers,
        game:GetService("LocalizationService").RobloxLocaleId
    ),
    Color = "Blue",
    Image = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. Player.UserId .. "&width=150&height=150&format=png",
    ImageSize = 52,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

InfoTab:Divider()

-- ==================== DISCORD COMMUNITY SECTION ====================
local DiscordSection = InfoTab:Section({
    Title = "Join Our Discord Community",
    Icon = "users",
})

InfoTab:Paragraph({
    Title = "üéÆ Connect & Engage",
    Desc = "Join thousands of players in our Discord community for updates, support, and exclusive content!",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

-- Discord API Configuration
local InviteCode = "UKYHGddQD3"
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

-- Universal HTTP Request Handler
local function HttpRequest(data)
    if syn and syn.request then
        return syn.request(data)
    elseif http and http.request then
        return http.request(data)
    elseif http_request then
        return http_request(data)
    elseif request then
        return request(data)
    else
        error("Your executor does not support HTTP requests.")
    end
end

local DiscordResponse
local DiscordErrorMessage = nil
local DiscordInfoParagraph

-- Fetch Discord Information
xpcall(function()
    local req = HttpRequest({
        Url = DiscordAPI,
        Method = "GET",
        Headers = {
            ["Accept"] = "application/json"
        }
    })

    if req and req.Body then
        DiscordResponse = HttpService:JSONDecode(req.Body)
    else
        error("Invalid response from Discord API.")
    end
end, function(err)
    warn("Error fetching Discord info: " .. tostring(err))
    DiscordErrorMessage = tostring(err)
    DiscordResponse = nil
end)

-- Display Discord Information
if DiscordResponse and DiscordResponse.guild then
    local guildName = DiscordResponse.guild.name or "Unknown Server"
    local memberCount = DiscordResponse.approximate_member_count or 0
    local onlineCount = DiscordResponse.approximate_presence_count or 0
    
    local ParagraphConfig = {
        Title = "üî∑ " .. guildName,
        Desc = 
            'üìä <font color="#3b82f6"><b>Members:</b></font> ' .. tostring(memberCount) ..
            '\nüü¢ <font color="#10b981"><b>Online:</b></font> ' .. tostring(onlineCount) ..
            '\nüìà <font color="#f59e0b"><b>Activity:</b></font> ' .. math.floor((onlineCount / math.max(memberCount, 1)) * 100) .. '% active',
        Color = "Red",
        ImageSize = 52,
        Buttons = {
            {
                Icon = "link",
                Title = "Copy Invite",
                Callback = function()
                    pcall(function()
                        setclipboard("https://discord.gg/" .. InviteCode)
                        WindUI:Notify({
                            Title = "‚úÖ Copied!",
                            Content = "Discord invite copied to clipboard.",
                            Duration = 3,
                            Icon = "copy",
                        })
                    end)
                end
            },
            {
                Icon = "refresh-cw",
                Title = "Update Stats",
                Callback = function()
                    xpcall(function()
                        local upd = HttpRequest({
                            Url = DiscordAPI,
                            Method = "GET",
                            Headers = {
                                ["Accept"] = "application/json"
                            }
                        })
                        if upd and upd.Body then
                            local UpdatedResponse = HttpService:JSONDecode(upd.Body)
                            if UpdatedResponse and UpdatedResponse.guild then
                                local newMembers = UpdatedResponse.approximate_member_count or 0
                                local newOnline = UpdatedResponse.approximate_presence_count or 0
                                local activity = math.floor((newOnline / math.max(newMembers, 1)) * 100)
                                
                                DiscordInfoParagraph:SetDesc(
                                    'üìä <font color="#3b82f6"><b>Members:</b></font> ' .. tostring(newMembers) ..
                                    '\nüü¢ <font color="#10b981"><b>Online:</b></font> ' .. tostring(newOnline) ..
                                    '\nüìà <font color="#f59e0b"><b>Activity:</b></font> ' .. activity .. '% active'
                                )
                                WindUI:Notify({
                                    Title = "üîÑ Updated!",
                                    Content = "Discord stats refreshed successfully.",
                                    Duration = 2,
                                    Icon = "check",
                                })
                            end
                        end
                    end, function(err)
                        warn("Error updating Discord info: " .. tostring(err))
                        WindUI:Notify({
                            Title = "‚ö†Ô∏è Update Failed",
                            Content = "Could not refresh Discord stats.",
                            Duration = 3,
                            Icon = "alert-circle",
                        })
                    end)
                end
            }
        }
    }

    -- Add guild icon if available
    if DiscordResponse.guild.icon then
        ParagraphConfig.Image = "https://cdn.discordapp.com/icons/" .. DiscordResponse.guild.id .. "/" .. DiscordResponse.guild.icon .. ".png?size=256"
    end

    -- Add banner if available
    if DiscordResponse.guild.banner then
        ParagraphConfig.Thumbnail = "https://cdn.discordapp.com/banners/" .. DiscordResponse.guild.id .. "/" .. DiscordResponse.guild.banner .. ".png?size=512"
        ParagraphConfig.ThumbnailSize = 80
    end

    DiscordInfoParagraph = InfoTab:Paragraph(ParagraphConfig)
else
    InfoTab:Paragraph({
        Title = "‚ö†Ô∏è Discord Info Unavailable",
        Desc = DiscordErrorMessage or "Unable to fetch Discord server information. Try again later!",
        Color = "Blue",
        ImageSize = 26,
    })
end

-- Quick Action Button
InfoTab:Button({
    Title = "üìã Copy Discord Link",
    Desc = "Copy invite link to clipboard",
    Locked = false,
    Callback = function()
        setclipboard("https://discord.gg/" .. InviteCode)
        WindUI:Notify({
            Title = "‚úÖ Link Copied!",
            Content = "Discord invite copied to clipboard",
            Duration = 3,
            Icon = "copy",
        })
    end
})

InfoTab:Space()

-- ==================== TAB 2: PLAYER ====================
local PlayerTab = Window:Tab({
    Title = "Player",
    Icon = "user-check",
    Locked = false,
})

local Section3 = PlayerTab:Section({
    Title = "Player Controls",
    Icon = "user-check",
})

PlayerTab:Paragraph({
    Title = "Player Controls",
    Desc = "Use the buttons below to control your player character",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

PlayerTab:Divider()

local Section4 = PlayerTab:Section({
    Title = "Movement System",
    Icon = "zap",
    Opened = true,
})

-- Infinite Jump Toggle
local infiniteJumpEnabled = false
local UserInputService = game:GetService("UserInputService")

PlayerTab:Toggle({
    Title = "Infinite Jump",
    Desc = "Press Space to jump infinitely",
    Icon = "arrow-up",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        infiniteJumpEnabled = state
        WindUI:Notify({
            Title = state and "Infinite Jump Enabled! üöÄ" or "Infinite Jump Disabled!",
            Content = state and "Press Space to jump infinitely" or "Jump mechanics restored to normal",
            Duration = 3,
        })
    end
})

UserInputService.JumpRequest:Connect(function()
    if infiniteJumpEnabled and Player.Character and Player.Character:FindFirstChild("Humanoid") then
        local humanoid = Player.Character.Humanoid
        if humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local ActiveSpeedBoost = false
local ActiveJumpBoost = false
local ActiveNoclip = false
local ActiveInstantPrompts = false
local ValueSpeed = 16
local ValueJumpHeight = 7.2
local OldSpeed = 16
local OldJumpHeight = 7.2

local function getCharacter()
    return LocalPlayer.Character
end

local function getHumanoid()
    local character = getCharacter()
    return character and character:FindFirstChildOfClass("Humanoid")
end

local function updateOriginalValues()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        OldSpeed = LocalPlayer.Character.Humanoid.WalkSpeed
        OldJumpHeight = LocalPlayer.Character.Humanoid.JumpHeight or 7.2
    end
end

updateOriginalValues()
LocalPlayer.CharacterAdded:Connect(updateOriginalValues)



PlayerTab:Divider()

-- Speed Controls
PlayerTab:Slider({
    Title = "Walk Speed Setting",
    Step = 1,
    Value = {
        Min = 16,
        Max = 500,
        Default = 16,
    },
    Callback = function(value)
        ValueSpeed = value
        print("üèÉ Walk speed set to: " .. value)
    end
})

PlayerTab:Toggle({
    Title = "Enable Speed Boost",
    Desc = "Boost your walking speed",
    Icon = "zap",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        ActiveSpeedBoost = state
        
        task.spawn(function()
            while ActiveSpeedBoost do
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    LocalPlayer.Character.Humanoid.WalkSpeed = ValueSpeed
                end
                task.wait(0.1)
            end
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = OldSpeed
            end
        end)
        
        print("üèÉ Speed Boost: " .. (state and "ON" or "OFF"))
    end
})

PlayerTab:Divider()

-- Jump Controls
PlayerTab:Slider({
    Title = "Jump Height Setting",
    Step = 1,
    Value = {
        Min = 7,
        Max = 200,
        Default = 50,
    },
    Callback = function(value)
        ValueJumpHeight = value
        print("ü¶ò Jump height set to: " .. value)
    end
})

PlayerTab:Toggle({
    Title = "Enable Jump Boost",
    Desc = "Increase your jump height",
    Icon = "move-up",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        ActiveJumpBoost = state
        
        task.spawn(function()
            while ActiveJumpBoost do
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    local humanoid = LocalPlayer.Character.Humanoid
                    humanoid.UseJumpPower = false
                    humanoid.JumpHeight = ValueJumpHeight
                end
                task.wait(0.1)
            end
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                local humanoid = LocalPlayer.Character.Humanoid
                humanoid.JumpHeight = 7.2
            end
        end)
        
        print("ü¶ò Jump Boost: " .. (state and "ON" or "OFF"))
    end
})

PlayerTab:Divider()

PlayerTab:Space()

-- Fly System
local IYMouse = Players.LocalPlayer:GetMouse()
local FLYING = false
local QEfly = true
local iyflyspeed = 1
local vehicleflyspeed = 1
local ActivateFly = false

local function sFLY(vfly)
    repeat task.wait() until Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart") and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    repeat task.wait() until IYMouse
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end

    local T = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0

    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro')
        local BV = Instance.new('BodyVelocity')
        BG.P = 9e4
        BG.Parent = T
        BV.Parent = T
        BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.CFrame = T.CFrame
        BV.Velocity = Vector3.new(0, 0, 0)
        BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            repeat task.wait()
                if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                    Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = 50
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.Velocity = Vector3.new(0, 0, 0)
                end
                BG.CFrame = workspace.CurrentCamera.CoordinateFrame
            until not FLYING
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:Destroy()
            BV:Destroy()
            if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
            end
        end)
    end
    flyKeyDown = IYMouse.KeyDown:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 's' then
            CONTROL.B = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'a' then
            CONTROL.L = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'd' then 
            CONTROL.R = (vfly and vehicleflyspeed or iyflyspeed)
        elseif QEfly and KEY:lower() == 'e' then
            CONTROL.Q = (vfly and vehicleflyspeed or iyflyspeed)*2
        elseif QEfly and KEY:lower() == 'q' then
            CONTROL.E = -(vfly and vehicleflyspeed or iyflyspeed)*2
        end
        pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
    end)
    flyKeyUp = IYMouse.KeyUp:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = 0
        elseif KEY:lower() == 's' then
            CONTROL.B = 0
        elseif KEY:lower() == 'a' then
            CONTROL.L = 0
        elseif KEY:lower() == 'd' then
            CONTROL.R = 0
        elseif KEY:lower() == 'e' then
            CONTROL.Q = 0
        elseif KEY:lower() == 'q' then
            CONTROL.E = 0
        end
    end)
    FLY()
end

local function NOFLY()
    FLYING = false
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end
    if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
        Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
    end
    pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

-- Mobile Fly
local velocityHandlerName = "BodyVelocity"
local gyroHandlerName = "BodyGyro"
local mfly1
local mfly2

local function UnMobileFly()
    pcall(function()
        FLYING = false
        local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        root:FindFirstChild(velocityHandlerName):Destroy()
        root:FindFirstChild(gyroHandlerName):Destroy()
        Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
        mfly1:Disconnect()
        mfly2:Disconnect()
    end)
end

local function MobileFly()
    UnMobileFly()
    FLYING = true

    local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local camera = workspace.CurrentCamera
    local v3none = Vector3.new()
    local v3zero = Vector3.new(0, 0, 0)
    local v3inf = Vector3.new(9e9, 9e9, 9e9)

    local controlModule = require(Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    local bv = Instance.new("BodyVelocity")
    bv.Name = velocityHandlerName
    bv.Parent = root
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = gyroHandlerName
    bg.Parent = root
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50

    mfly1 = Players.LocalPlayer.CharacterAdded:Connect(function()
        local bv = Instance.new("BodyVelocity")
        bv.Name = velocityHandlerName
        bv.Parent = root
        bv.MaxForce = v3zero
        bv.Velocity = v3zero

        local bg = Instance.new("BodyGyro")
        bg.Name = gyroHandlerName
        bg.Parent = root
        bg.MaxTorque = v3inf
        bg.P = 1000
        bg.D = 50
    end)

    mfly2 = RunService.RenderStepped:Connect(function()
        root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        camera = workspace.CurrentCamera
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
            local humanoid = Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
            local VelocityHandler = root:FindFirstChild(velocityHandlerName)
            local GyroHandler = root:FindFirstChild(gyroHandlerName)

            VelocityHandler.MaxForce = v3inf
            GyroHandler.MaxTorque = v3inf
            humanoid.PlatformStand = true
            GyroHandler.CFrame = camera.CoordinateFrame
            VelocityHandler.Velocity = v3none

            local direction = controlModule:GetMoveVector()
            if direction.X > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.X < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.Z > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
            if direction.Z < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
        end
    end)
end

PlayerTab:Slider({
    Title = "Fly Speed",
    Step = 0.1,
    Value = {
        Min = 0.1,
        Max = 10,
        Default = 1
    },
    Callback = function(val)
        iyflyspeed = val
    end
})

PlayerTab:Toggle({
    Title = "Fly",
    Desc = "Enable flying with WASD controls",
    Icon = "plane",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        ActivateFly = state
        task.spawn(function()
            if not FLYING and ActivateFly then
                if UserInputService.TouchEnabled then
                    MobileFly()
                else
                    NOFLY()
                    task.wait()
                    sFLY()
                end
            elseif FLYING and not ActivateFly then
                if UserInputService.TouchEnabled then
                    UnMobileFly()
                else
                    NOFLY()
                end
            end
        end)
    end
})

PlayerTab:Space()

-- ==================== AUTO MINE TAB ====================
local MainTab = Window:Tab({
    Title = "MainFarm",
    Icon = "house"
})

local Section = MainTab:Section({
    Title = "Auto Mine",
    Icon = "pickaxe"
})

-- Global settings
_G.AutoMine = _G.AutoMine or false
_G.MineTheseOres = _G.MineTheseOres or {}
_G.TweenSpeed = _G.TweenSpeed or 67
_G.FilterByArea = _G.FilterByArea or false
_G.SelectedAreas = _G.SelectedAreas or {}
_G.MineMode = _G.MineMode or "Ores"

-- Find tool service
local ToolService
pcall(function()
    ToolService = ReplicatedStorage.Shared.Packages.Knit.Services.ToolService.RF.ToolActivated
end)

-- Rock and ore definitions
local RockOreTypes = {
    Pebble = {"Stone", "Sand Stone", "Copper", "Iron", "Poopite"},
    Rock = {"Sand Stone", "Copper", "Iron", "Tin", "Silver"},
    Boulder = {"Copper", "Iron", "Tin", "Silver", "Gold", "Platinum"}
}

local AllOres = {
    "Stone", "Sand Stone", "Copper", "Iron", "Tin", "Silver", "Gold",
    "Platinum", "Cobalt", "Titanium", "Diamond", "Ruby", "Emerald"
}

local AllRocks = {"Pebble", "Rock", "Boulder", "Basalt Rock"}

-- Helper functions
local function GetHRP()
    local char = LocalPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function GetRockType(rock)
    if not rock then return nil end
    
    local rockType = rock:GetAttribute("RockType")
    if rockType then return tostring(rockType) end
    
    if RockOreTypes[rock.Name] then
        return rock.Name
    end
    
    return nil
end

local function IsDesiredRock(rock)
    if not rock then return false end
    if not _G.MineTheseOres or #_G.MineTheseOres == 0 then return true end
    
    local rockType = GetRockType(rock)
    if not rockType then return false end
    
    local drops = RockOreTypes[rockType]
    if not drops then return false end
    
    for _, desired in ipairs(_G.MineTheseOres) do
        for _, drop in ipairs(drops) do
            if string.lower(drop) == string.lower(desired) then
                return true
            end
        end
    end
    
    return false
end

local function GetRockHealth(rock)
    if not rock then return nil end
    
    local health = rock:GetAttribute("Health")
    if health then return health end
    
    local part = rock:IsA("BasePart") and rock or rock:FindFirstChildWhichIsA("BasePart")
    if part then
        health = part:GetAttribute("Health")
        if health then return health end
    end
    
    return nil
end

local function FindNearestRock()
    local hrp = GetHRP()
    if not hrp then return nil end
    
    local rocksFolder = Workspace:FindFirstChild("Rocks")
    if not rocksFolder then return nil end
    
    local nearest = nil
    local minDist = math.huge
    
    for _, area in ipairs(rocksFolder:GetChildren()) do
        for _, rock in ipairs(area:GetDescendants()) do
            if rock:IsA("Model") or rock:IsA("BasePart") then
                if IsDesiredRock(rock) then
                    local health = GetRockHealth(rock)
                    if health and health > 0 then
                        local part = rock:IsA("BasePart") and rock or rock:FindFirstChildWhichIsA("BasePart")
                        if part then
                            local dist = (hrp.Position - part.Position).Magnitude
                            if dist < minDist then
                                nearest = rock
                                minDist = dist
                            end
                        end
                    end
                end
            end
        end
    end
    
    return nearest
end

local function TweenToRock(rock)
    local hrp = GetHRP()
    if not hrp or not rock then return end
    
    local part = rock:IsA("BasePart") and rock or rock:FindFirstChildWhichIsA("BasePart")
    if not part then return end
    
    local targetPos = part.Position + Vector3.new(0, 3, 0)
    local distance = (hrp.Position - targetPos).Magnitude
    local time = distance / (_G.TweenSpeed or 67)
    
    local tween = TweenService:Create(hrp, TweenInfo.new(time, Enum.EasingStyle.Linear), {
        CFrame = CFrame.new(targetPos)
    })
    
    tween:Play()
    tween.Completed:Wait()
end

local function ActivateTool()
    if ToolService then
        pcall(function()
            ToolService:InvokeServer("Pickaxe")
        end)
    end
end

-- Auto mine toggle
MainTab:Section({Title = "Master", Icon = "play"}):Toggle({
    Title = "Auto Mine (Master)",
    Desc = "Enable/disable auto-miner",
    Value = _G.AutoMine,
    Callback = function(value)
        _G.AutoMine = value
        vu2:Notify({
            Title = "Auto Mine",
            Content = value and "Enabled" or "Disabled",
            Duration = 1.5
        })
    end
})

-- Mode selection
MainTab:Section({Title = "Selection & Mode", Icon = "settings-2"}):Dropdown({
    Title = "Mine Type",
    Desc = "Choose what to mine",
    Values = {"Ores", "Rocks"},
    Value = _G.MineMode,
    Multi = false,
    Callback = function(value)
        _G.MineMode = value
        _G.MineTheseOres = {_G.MineMode == "Ores" and AllOres[1] or AllRocks[1]}
    end
})

-- Ore/Rock selection
MainTab:Section({Title = "Selection & Mode", Icon = "settings-2"}):Dropdown({
    Title = "Ore Drops",
    Desc = "Select ores to mine",
    Values = AllOres,
    Value = {},
    Multi = true,
    Callback = function(value)
        if _G.MineMode == "Ores" then
            _G.MineTheseOres = type(value) == "table" and value or {value}
        end
    end
})

-- Speed slider
MainTab:Section({Title = "Options", Icon = "settings"}):Slider({
    Title = "Tween Speed",
    Desc = "Movement speed to rocks",
    Step = 1,
    Value = {Min = 1, Max = 100, Default = _G.TweenSpeed},
    Callback = function(value)
        _G.TweenSpeed = value
    end
})

-- Main mining loop
task.spawn(function()
    local currentRock = nil
    
    while true do
        task.wait(0.12)
        
        if not _G.AutoMine then
            currentRock = nil
            continue
        end
        
        local hrp = GetHRP()
        if not hrp then
            task.wait(0.4)
            continue
        end
        
        -- Check current rock
        if currentRock and currentRock.Parent then
            local health = GetRockHealth(currentRock)
            if health and health > 0 and IsDesiredRock(currentRock) then
                -- Keep mining
                ActivateTool()
                task.wait(0.05)
                continue
            end
        end
        
        -- Find new rock
        currentRock = FindNearestRock()
        
        if not currentRock then
            task.wait(0.28)
            continue
        end
        
        -- Move to rock
        TweenToRock(currentRock)
        
        -- Start mining
        while currentRock and currentRock.Parent and _G.AutoMine do
            local health = GetRockHealth(currentRock)
            if not health or health <= 0 then
                break
            end
            
            ActivateTool()
            task.wait(0.05)
        end
        
        currentRock = nil
    end
end)

local v221 = Window:Tab({
        Title = "Forge",
        Icon = "anvil"
    })
    repeat
        task.wait()
    until game:IsLoaded()
    local v222 = Players.LocalPlayer
    repeat
        task.wait()
    until v222 and v222:FindFirstChild("PlayerGui")
    local vu223 = v222:WaitForChild("PlayerGui")
    local function vu230(p224)
        local v225 = ReplicatedStorage
        local v226, v227, v228 = ipairs(p224)
        while true do
            local v229
            v228, v229 = v226(v227, v228)
            if v228 == nil then
                break
            end
            if not v225 then
                return nil
            end
            v225 = v225:FindFirstChild(v229)
        end
        return v225
    end
    local function vu240(p231)
        local v232 = ReplicatedStorage:FindFirstChild("Controllers")
        if v232 and v232:FindFirstChild("ForgeController") then
            local v233 = v232.ForgeController:FindFirstChild(p231)
            if v233 and v233:IsA("ModuleScript") then
                local v234, v235 = pcall(require, v233)
                if v234 and type(v235) == "table" then
                    return v235, v233
                end
            end
        end
        local v236 = ReplicatedStorage:FindFirstChild("Shared")
        if v236 and v236:FindFirstChild("Controllers") and v236.Controllers:FindFirstChild("ForgeController") then
            local v237 = v236.Controllers.ForgeController:FindFirstChild(p231)
            if v237 and v237:IsA("ModuleScript") then
                local v238, v239 = pcall(require, v237)
                if v238 and type(v239) == "table" then
                    return v239, v237
                end
            end
        end
        return nil, nil
    end
    local vu241 = {}
    local function vu247(pu242, pu243)
        local vu244, _ = vu240(pu242)
        if not vu244 then
            return false, "module_not_found"
        end
        if not vu241[pu242] then
            vu241[pu242] = vu244.Start
        end
        function vu244.Start()
            local v245, v246 = pcall(function()
                return pu243(vu244)
            end)
            if v245 then
                return v246
            else
                warn("Patch override error for", pu242, v246)
                if vu241[pu242] then
                    return vu241[pu242]
                else
                    return nil
                end
            end
        end
        return true
    end
    local function vu250(p248)
        local v249, _ = vu240(p248)
        if not v249 then
            return false
        end
        if not vu241[p248] then
            return false
        end
        v249.Start = vu241[p248]
        vu241[p248] = nil
        return true
    end
    local function vu254(_, _, p251)
        local vu252 = vu223:FindFirstChild("Forge")
        if vu252 and vu252:FindFirstChild("MeltMinigame") then
            pcall(function()
                vu252.MeltMinigame.Visible = true
                local vu253 = not vu252.MeltMinigame:FindFirstChild("Bar", true) and vu252.MeltMinigame.Bar
                if vu253 then
                    vu253 = vu252.MeltMinigame.Bar.Area
                end
                if vu253 and vu253:IsA("Frame") then
                    pcall(function()
                        TweenService:Create(vu253, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            Size = UDim2.fromScale(1, vu253.Size.Y.Scale)
                        }):Play()
                    end)
                end
                task.wait(0.28)
                vu252.MeltMinigame.Visible = false
            end)
        else
            task.wait(0.25)
        end
        return p251 and p251.StartTime or workspace:GetServerTimeNow(), true
    end
    local function vu258(_, _, p255)
        local vu256 = vu223:FindFirstChild("Forge")
        if vu256 and vu256:FindFirstChild("PourMinigame") then
            pcall(function()
                vu256.PourMinigame.Visible = true
                local vu257 = vu256.PourMinigame.Timer
                if vu257 then
                    vu257 = vu256.PourMinigame.Timer.Bar
                end
                if vu257 and vu257:IsA("Frame") then
                    pcall(function()
                        TweenService:Create(vu257, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            Size = UDim2.fromScale(1, vu257.Size.Y.Scale)
                        }):Play()
                    end)
                end
                task.wait(0.28)
                vu256.PourMinigame.Visible = false
            end)
        else
            task.wait(0.25)
        end
        return p255 and p255.StartTime or workspace:GetServerTimeNow()
    end
    v221:Button({
        Title = "Open Forge UI",
        Desc = "Invoke Proximity -> StartForge to open the Forge UI",
        Callback = function()
            local vu259 = vu230({
                "Shared",
                "Packages",
                "Knit",
                "Services",
                "ProximityService",
                "RF",
                "Forge"
            }) or vu230({
                "Controllers",
                "ForgeController",
                "RF",
                "Forge"
            })
            local vu260 = vu230({
                "Shared",
                "Packages",
                "Knit",
                "Services",
                "ForgeService",
                "RF",
                "StartForge"
            }) or vu230({
                "Controllers",
                "ForgeController",
                "RF",
                "StartForge"
            })
            local vu261 = workspace:FindFirstChild("Proximity")
            if vu261 then
                vu261 = workspace.Proximity:FindFirstChild("Forge")
            end
            if vu261 then
                if vu259 then
                    pcall(function()
                        vu259:InvokeServer(vu261)
                    end)
                    task.wait(0.12)
                end
                if vu260 then
                    pcall(function()
                        vu260:InvokeServer(vu261)
                    end)
                end
                print("[Forge Helper] Opened Forge UI (attempted).")
            else
                warn("[Forge Helper] forge object not found in workspace.Proximity")
            end
        end
    })
    v221:Divider()
    local vu262 = false
    local vu263 = false
    v221:Toggle({
        Title = "Complete Melt",
        Desc = "When enabled, Melt minigame will auto-complete visually",
        Type = "Checkbox",
        Value = false,
        Callback = function(p264)
            vu262 = p264
            if vu262 then
                local v265, v266 = vu247("MeltMinigame", vu254)
                if v265 then
                    print("[Forge Helper] Melt auto-complete ENABLED")
                else
                    warn("[Forge Helper] Unable to patch MeltMinigame:", v266 or "unknown")
                end
            elseif vu250("MeltMinigame") then
                print("[Forge Helper] Melt auto-complete DISABLED")
            else
                print("[Forge Helper] Melt patch not found/restored")
            end
        end
    })
    v221:Toggle({
        Title = "Complete Pour",
        Desc = "When enabled, Pour minigame will auto-complete visually",
        Type = "Checkbox",
        Value = false,
        Callback = function(p267)
            vu263 = p267
            if vu263 then
                local v268, v269 = vu247("PourMinigame", vu258)
                if v268 then
                    print("[Forge Helper] Pour auto-complete ENABLED")
                else
                    warn("[Forge Helper] Unable to patch PourMinigame:", v269 or "unknown")
                end
            elseif vu250("PourMinigame") then
                print("[Forge Helper] Pour auto-complete DISABLED")
            else
                print("[Forge Helper] Pour patch not found/restored")
            end
        end
    })
    local vu270 = false
    v221:Toggle({
        Title = "Auto Hammer",
        Desc = "Automatically completes hammer minigame",
        Type = "Checkbox",
        Value = false,
        Callback = function(p271)
            vu270 = p271
        end
    })
    task.spawn(function()
        while true do
            local vu272 = false
            local function v273()
                vu272 = true
            end
            task.wait(0.05)
            if vu270 then
                local v274 = vu223:FindFirstChild("Forge")
                if not v274 then
                    v273()
                end
                local v275 = v274:FindFirstChild("HammerMinigame")
                if not (v275 and v275.Visible) then
                    v273()
                end
                local v276 = workspace:FindFirstChild("Debris")
                if not v276 then
                    v273()
                end
                local v277, v278, v279 = ipairs(v276:GetChildren())
                while true do
                    local vu280
                    v279, vu280 = v277(v278, v279)
                    if v279 == nil then
                        break
                    end
                    if vu280:FindFirstChild("ClickDetector") then
                        pcall(function()
                            fireclickdetector(vu280.ClickDetector)
                        end)
                    end
                end
            end
            if vu272 then
                return
            end
        end
    end)
    local vu281 = false
    local vu282 = nil
    v221:Toggle({
        Title = "Auto-Perfect Hammer",
        Desc = "Automatically \'perfect\' each Hammer note (very simple)",
        Type = "Checkbox",
        Value = false,
        Callback = function(p283)
            vu281 = p283
            local v284, _ = vu240("HammerMinigame")
            if v284 then
                if vu281 then
                    if not vu282 then
                        vu282 = v284.CreateNote
                    end
                    function v284.CreateNote(_, p285)
                        local v286 = (p285 and p285.Lifetime or 1) * 25 / 44
                        task.wait(v286)
                        return true
                    end
                    print("[Forge Helper] Hammer auto-perfect ENABLED")
                elseif vu282 and v284 then
                    v284.CreateNote = vu282
                    vu282 = nil
                    print("[Forge Helper] Hammer auto-perfect DISABLED")
                else
                    print("[Forge Helper] Hammer auto-perfect: nothing to restore")
                end
            else
                warn("[Forge Helper] HammerMinigame module not found.")
            end
        end
    })
    print("Forge Helper loaded.")



-- ==================== TAB 6: SETTINGS ====================
local Tab6 = Window:Tab({
    Title = "Settings",
    Icon = "settings",
    Locked = false,
})

local SettingsSection1 = Tab6:Section({
    Title = "Window Settings",
    Icon = "layout",
})

Tab6:Space()

local TransparencyToggle = Tab6:Toggle({
    Title = "Window Transparency",
    Desc = "Toggle window transparency on/off",
    Icon = "eye",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        Window:ToggleTransparency(state)
        print("Transparency: " .. tostring(state))
    end
})

Tab6:Divider()

local SettingsSection2 = Tab6:Section({
    Title = "Keybind Settings",
    Icon = "keyboard",
})

local KeybindInput = Tab6:Input({
    Title = "Toggle UI Keybind",
    Desc = "Type ONE letter or key (e.g., Q or RightControl)",
    Value = "RightControl",
    InputIcon = "keyboard",
    Type = "Input",
    Placeholder = "Enter key...",
    Callback = function(input)
        input = input:gsub("^%s*(.-)%s*$", "%1")
        
        local keyCode
        
        if #input == 1 then
            local upperInput = input:upper()
            keyCode = Enum.KeyCode[upperInput]
        else
            local success, result = pcall(function()
                return Enum.KeyCode[input]
            end)
            if success then
                keyCode = result
            end
        end
        
        if keyCode then
            Window:SetToggleKey(keyCode)
            print("Keybind set to: " .. input)
            WindUI:Notify({
                Title = "Keybind Updated",
                Content = "Press '" .. input .. "' to toggle UI",
                Duration = 3,
                Icon = "check",
            })
        else
            print("Invalid key: " .. input)
            WindUI:Notify({
                Title = "Invalid Key",
                Content = "Enter a single letter (Q) or key name (RightControl)",
                Duration = 4,
                Icon = "x",
            })
        end
    end
})

Window:SetToggleKey(Enum.KeyCode.RightControl)

Tab6:Space()

local MiscTab = Window:Tab({
    Title = "Misc",
    Icon = "folder",
    Locked = false,
})

local ToggleAntiAFK = MiscTab:Toggle({
    Title = "Anti AFK",
    Desc = "Prevents automatic idle kick",
    Icon = "shield-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if state then
            local player = game.Players.LocalPlayer

            -- Disconnect existing idle connections if any
            if getgenv().AntiAFKConnection then
                getgenv().AntiAFKConnection:Disconnect()
            end

            -- Connect to Idled event
            getgenv().AntiAFKConnection = player.Idled:Connect(function()
                -- simulate click or jump to prevent kick
                game:GetService("VirtualUser"):CaptureController()
                game:GetService("VirtualUser"):ClickButton2(Vector2.new())
                print("‚è± Anti-AFK triggered!")
            end)

            print("‚úÖ Anti-AFK enabled")
        else
            -- Disconnect Anti-AFK
            if getgenv().AntiAFKConnection then
                getgenv().AntiAFKConnection:Disconnect()
                getgenv().AntiAFKConnection = nil
            end
            print("‚õî Anti-AFK disabled")
        end
    end
})

local Buttonpowersave = MiscTab:Button({
    Title = "Power Save Mode",
    Desc = "Open Power Save Script",
    Locked = false,
    Callback = function()
        print("Opening Power Save Script...")
        loadstring(game:HttpGet("https://raw.githubusercontent.com/FryzerHub/SubScripts/refs/heads/main/screen%20saver"))()
    end
})
