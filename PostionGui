local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")

-- Gradient text function (used in popup)
local function gradient(text, startColor, endColor)
    local result = ""
    for i = 1, #text do
        local t = (i - 1) / math.max(#text - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)
        result = result .. string.format('<font color="rgb(%d, %d, %d)">%s</font>', r, g, b, text:sub(i, i))
    end
    return result
end

-- Popup before loading
local Confirmed = false
WindUI:Popup({
    Title = "Confirmation",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Content = "Fryzer Hub " .. gradient("FH", Color3.fromHex("#00FF87"), Color3.fromHex("#60EFFF")),
    Buttons = {
        {
            Title = "Cancel",
            Variant = "Secondary",
        },
        {
            Title = "Continue",
            Icon = "arrow-right",
            Callback = function() Confirmed = true end,
            Variant = "Primary",
        }
    }
})
repeat task.wait() until Confirmed

-- Window creation with Key System
local Window = WindUI:CreateWindow({
    Title = "Fryzer Hub",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Author = "99 nights in forest",
    Folder = "YourHub",
    Size = UDim2.fromOffset(580, 360),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    ScrollBarEnabled = true,
    KeySystem = {
        Key = {"1234", "CM"},
        Note = "Enter the key to proceed.",
        URL = "https://your-key-link.com",
        SaveKey = false,
    },
    
    User = {
        Enabled = true,
        Anonymous = false,
        Username = LocalPlayer.DisplayName,
        UserId = LocalPlayer.UserId,
        Callback = function()
            print("User icon clicked:", LocalPlayer.Name)
        end
    }
})

-- UI open button
Window:EditOpenButton({
    Title = "Open UI",
    Icon = "monitor",
    CornerRadius = UDim.new(0, 16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    Draggable = true,
})

-- Main Tab
local PlayerTab = Window:Tab({ Title = "Player", Icon = "user" })

-- Welcome Paragraph
PlayerTab:Paragraph({
    Title = "Welcome to Fryzer Hub!",
    Content = "Hello " .. LocalPlayer.DisplayName .. "! You're running WindUI successfully."
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Default speed
local defaultSpeed = 16

-- Toggle for WalkSpeed
PlayerTab:Toggle({
    Title = "WalkSpeed", 
    Value = false,
    Callback = function(state)
        if state then
            -- Set to slider value when enabled
            LocalPlayer.Character.Humanoid.WalkSpeed = _G.CurrentWalkSpeed or defaultSpeed
        else
            -- Reset to Roblox default when disabled
            LocalPlayer.Character.Humanoid.WalkSpeed = defaultSpeed
        end
        print("WalkSpeed enabled:", state)
    end
})

-- Slider to adjust WalkSpeed
PlayerTab:Slider({
    Title = "Speed Changer",
    Value = {
        Min = 16,
        Max = 100,
        Default = 16
    },
    Callback = function(val)
        _G.CurrentWalkSpeed = val
        -- If toggle is enabled, update immediately
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.WalkSpeed = val
        end
        print("WalkSpeed set to:", val)
    end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Default jump height
local defaultJumpHeight = 7.2 -- Roblox default JumpHeight

-- Toggle for Jump Height
PlayerTab:Toggle({
    Title = "Enable Jump Power", 
    Value = false,
    Callback = function(state)
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            if state then
                humanoid.UseJumpPower = false -- Ensure JumpHeight is used
                humanoid.JumpHeight = _G.CurrentJumpHeight or defaultJumpHeight
            else
                humanoid.JumpHeight = defaultJumpHeight
            end
        end
        print("Jump Height enabled:", state)
    end
})

-- Slider to adjust Jump Height
PlayerTab:Slider({
    Title = "Jump Power",
    Value = {
        Min = 7.2,
        Max = 50,
        Default = 7.2
    },
    Callback = function(val)
        _G.CurrentJumpHeight = val
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.JumpHeight = val
        end
        print("Jump Height set to:", val)
    end
})


local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local IYMouse = Players.LocalPlayer:GetMouse()
local FLYING = false
local QEfly = true
local iyflyspeed = 1
local vehicleflyspeed = 1
local ActivateFly = false

local function sFLY(vfly)
    repeat wait() until Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart") and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    repeat wait() until IYMouse
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end

    local T = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0

    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro')
        local BV = Instance.new('BodyVelocity')
        BG.P = 9e4
        BG.Parent = T
        BV.Parent = T
        BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.CFrame = T.CFrame
        BV.Velocity = Vector3.new(0, 0, 0)
        BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            repeat wait()
                if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                    Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = 50
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.Velocity = Vector3.new(0, 0, 0)
                end
                BG.CFrame = workspace.CurrentCamera.CoordinateFrame
            until not FLYING
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:Destroy()
            BV:Destroy()
            if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
            end
        end)
    end
    flyKeyDown = IYMouse.KeyDown:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 's' then
            CONTROL.B = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'a' then
            CONTROL.L = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'd' then 
            CONTROL.R = (vfly and vehicleflyspeed or iyflyspeed)
        elseif QEfly and KEY:lower() == 'e' then
            CONTROL.Q = (vfly and vehicleflyspeed or iyflyspeed)*2
        elseif QEfly and KEY:lower() == 'q' then
            CONTROL.E = -(vfly and vehicleflyspeed or iyflyspeed)*2
        end
        pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
    end)
    flyKeyUp = IYMouse.KeyUp:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = 0
        elseif KEY:lower() == 's' then
            CONTROL.B = 0
        elseif KEY:lower() == 'a' then
            CONTROL.L = 0
        elseif KEY:lower() == 'd' then
            CONTROL.R = 0
        elseif KEY:lower() == 'e' then
            CONTROL.Q = 0
        elseif KEY:lower() == 'q' then
            CONTROL.E = 0
        end
    end)
    FLY()
end

local function NOFLY()
    FLYING = false
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end
    if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
        Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
    end
    pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

local velocityHandlerName = "BodyVelocity"
local gyroHandlerName = "BodyGyro"
local mfly1
local mfly2

local function UnMobileFly()
    pcall(function()
        FLYING = false
        local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        root:FindFirstChild(velocityHandlerName):Destroy()
        root:FindFirstChild(gyroHandlerName):Destroy()
        Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
        mfly1:Disconnect()
        mfly2:Disconnect()
    end)
end

local function MobileFly()
    UnMobileFly()
    FLYING = true

    local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local camera = workspace.CurrentCamera
    local v3none = Vector3.new()
    local v3zero = Vector3.new(0, 0, 0)
    local v3inf = Vector3.new(9e9, 9e9, 9e9)

    local controlModule = require(Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    local bv = Instance.new("BodyVelocity")
    bv.Name = velocityHandlerName
    bv.Parent = root
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = gyroHandlerName
    bg.Parent = root
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50

    mfly1 = Players.LocalPlayer.CharacterAdded:Connect(function()
        local bv = Instance.new("BodyVelocity")
        bv.Name = velocityHandlerName
        bv.Parent = root
        bv.MaxForce = v3zero
        bv.Velocity = v3zero

        local bg = Instance.new("BodyGyro")
        bg.Name = gyroHandlerName
        bg.Parent = root
        bg.MaxTorque = v3inf
        bg.P = 1000
        bg.D = 50
    end)

    mfly2 = RunService.RenderStepped:Connect(function()
        root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        camera = workspace.CurrentCamera
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
            local humanoid = Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
            local VelocityHandler = root:FindFirstChild(velocityHandlerName)
            local GyroHandler = root:FindFirstChild(gyroHandlerName)

            VelocityHandler.MaxForce = v3inf
            GyroHandler.MaxTorque = v3inf
            humanoid.PlatformStand = true
            GyroHandler.CFrame = camera.CoordinateFrame
            VelocityHandler.Velocity = v3none

            local direction = controlModule:GetMoveVector()
            if direction.X > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.X < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.Z > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
            if direction.Z < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
        end
    end)
end

-- Fly Speed Slider
PlayerTab:Slider({
    Title = "Fly Speed",
    Value = {
        Min = 0.1,
        Max = 10,
        Default = 1
    },
    Callback = function(val)
        iyflyspeed = val
    end
})

-- Fly Toggle
PlayerTab:Toggle({
    Title = "Fly", 
    Value = false,
    Callback = function(state)
        ActivateFly = state
        task.spawn(function()
            if not FLYING and ActivateFly then
                if UserInputService.TouchEnabled then
                    MobileFly()
                else
                    NOFLY()
                    wait()
                    sFLY()
                end
            elseif FLYING and not ActivateFly then
                if UserInputService.TouchEnabled then
                    UnMobileFly()
                else
                    NOFLY()
                end
            end
        end)
    end
})

-- F key toggle for fly (optional - you can remove this if not needed)
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.F then
        if not FLYING and ActivateFly then
            if UserInputService.TouchEnabled then
                MobileFly()
            else
                NOFLY()
                wait()
                sFLY()
            end
        elseif FLYING and ActivateFly then
            if UserInputService.TouchEnabled then
                UnMobileFly()
            else
                NOFLY()
            end
        end
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local noclipConnection
local noclipEnabled = false

PlayerTab:Toggle({
    Title = "Noclip", 
    Value = false,
    Callback = function(state)
        noclipEnabled = state

        if state then
            -- Start noclip
            noclipConnection = RunService.Stepped:Connect(function()
                local character = LocalPlayer.Character
                if character then
                    for _, part in pairs(character:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            -- Stop noclip and restore collisions
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
            local character = LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end

        print("Noclip", state)
    end
})

local esptpTab = Window:Tab({ Title = "ESP & TP", Icon = "send" })

-- ESP State Variables
local ActiveEspItems = false
local ActiveEspEnemy = false
local ActiveEspChildren = false
local ActiveEspPeltTrader = false
local ActiveDistanceEsp = false

-- ESP Creation Function
local function CreateEsp(Char, Color, Text, Parent, number)
    if not Char or not Parent or not Parent:IsA("BasePart") then return end
    if Char:FindFirstChildOfClass("Highlight") or Parent:FindFirstChild("ESP") then return end

    -- Create Highlight
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.Adornee = Char
    highlight.FillColor = Color
    highlight.FillTransparency = 1
    highlight.OutlineColor = Color
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = Char

    -- Create Billboard
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP"
    billboard.Size = UDim2.new(0, 50, 0, 25)
    billboard.AlwaysOnTop = true
    billboard.StudsOffset = Vector3.new(0, number or 2, 0)
    billboard.Adornee = Parent
    billboard.Parent = Parent

    -- Create Label
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = Text
    label.TextColor3 = Color
    label.TextScaled = true
    label.Parent = billboard

    -- Distance Update Task
    task.spawn(function()
        local RunService = game:GetService("RunService")
        local Workspace = game:GetService("Workspace")
        while highlight.Parent and billboard.Parent and Parent.Parent do
            local camera = Workspace.CurrentCamera
            if ActiveDistanceEsp and camera and Parent:IsA("BasePart") then
                local distance = (camera.CFrame.Position - Parent.Position).Magnitude
                label.Text = Text .. " (" .. math.floor(distance + 0.5) .. " m)"
            else
                label.Text = Text
            end
            RunService.Heartbeat:Wait()
        end
        -- Cleanup
        if highlight.Parent then highlight:Destroy() end
        if billboard.Parent then billboard:Destroy() end
    end)
end

-- ESP Removal Function
local function RemoveEsp(Char, Parent)
    if Char and Char:FindFirstChildOfClass("Highlight") then
        Char:FindFirstChildOfClass("Highlight"):Destroy()
    end
    if Parent and Parent:FindFirstChild("ESP") then
        Parent:FindFirstChild("ESP"):Destroy()
    end
end

-- Function to Update ESP for Items
local function UpdateItemsEsp()
    if ActiveEspItems then
        for _, obj in pairs(game.Workspace.Items:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart then
                CreateEsp(obj, Color3.fromRGB(255, 255, 0), obj.Name, obj.PrimaryPart, 2)
            end
        end
    else
        for _, obj in pairs(game.Workspace.Items:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

-- Function to Update ESP for Enemies
local function UpdateEnemiesEsp()
    if ActiveEspEnemy then
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               not (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                    obj.Name == "Lost Child3" or obj.Name == "Lost Child4" or
                    obj.Name == "Pelt Trader") then
                CreateEsp(obj, Color3.fromRGB(255, 0, 0), obj.Name, obj.PrimaryPart, 3)
            end
        end
    else
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               not (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                    obj.Name == "Lost Child3" or obj.Name == "Lost Child4" or
                    obj.Name == "Pelt Trader") then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

-- Function to Update ESP for Children
local function UpdateChildrenEsp()
    if ActiveEspChildren then
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                obj.Name == "Lost Child3" or obj.Name == "Lost Child4") then
                CreateEsp(obj, Color3.fromRGB(0, 255, 0), obj.Name, obj.PrimaryPart, 3)
            end
        end
    else
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and
               (obj.Name == "Lost Child" or obj.Name == "Lost Child2" or
                obj.Name == "Lost Child3" or obj.Name == "Lost Child4") then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

-- Function to Update ESP for Pelt Trader
local function UpdatePeltTraderEsp()
    if ActiveEspPeltTrader then
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and obj.Name == "Pelt Trader" then
                CreateEsp(obj, Color3.fromRGB(0, 255, 255), obj.Name, obj.PrimaryPart, 3)
            end
        end
    else
        for _, obj in pairs(game.Workspace.Characters:GetChildren()) do
            if obj:IsA("Model") and obj.PrimaryPart and obj.Name == "Pelt Trader" then
                RemoveEsp(obj, obj.PrimaryPart)
            end
        end
    end
end

-- ESP Dropdown (Multi-select)
esptpTab:Dropdown({
    Title = "ESP Types",
    Values = {"Items", "Enemies", "Children", "Pelt Trader"},
    Value = {}, -- Empty initial selection
    Multi = true,
    AllowNone = true,
    Flag = "EspTypes",
    Callback = function(values)
        -- Reset all ESP states
        ActiveEspItems = false
        ActiveEspEnemy = false
        ActiveEspChildren = false
        ActiveEspPeltTrader = false

        -- Enable selected ESP types
        for _, espType in pairs(values) do
            if espType == "Items" then
                ActiveEspItems = true
            elseif espType == "Enemies" then
                ActiveEspEnemy = true
            elseif espType == "Children" then
                ActiveEspChildren = true
            elseif espType == "Pelt Trader" then
                ActiveEspPeltTrader = true
            end
        end

        -- Update ESP immediately
        UpdateItemsEsp()
        UpdateEnemiesEsp()
        UpdateChildrenEsp()
        UpdatePeltTraderEsp()

        print("ESP Types Selected:", game:GetService("HttpService"):JSONEncode(values))
    end
})

-- ESP Distance Toggle
esptpTab:Toggle({
    Title = "Show Distance in ESP",
    Value = false,
    Flag = "EspDistance",
    Callback = function(state)
        ActiveDistanceEsp = state
        -- Update all active ESPs to reflect distance change
        if ActiveEspItems then UpdateItemsEsp() end
        if ActiveEspEnemy then UpdateEnemiesEsp() end
        if ActiveEspChildren then UpdateChildrenEsp() end
        if ActiveEspPeltTrader then UpdatePeltTraderEsp() end
        print("Show Distance in ESP:", state)
    end
})

-- Event-driven ESP updates
local itemsConnection, charactersConnection

local function setupEspConnections()
    if itemsConnection then itemsConnection:Disconnect() end
    if charactersConnection then charactersConnection:Disconnect() end

    itemsConnection = game.Workspace.Items.ChildAdded:Connect(function(child)
        if ActiveEspItems and child:IsA("Model") and child.PrimaryPart then
            CreateEsp(child, Color3.fromRGB(255, 255, 0), child.Name, child.PrimaryPart, 2)
        end
    end)

    game.Workspace.Items.ChildRemoved:Connect(function(child)
        if child:IsA("Model") and child.PrimaryPart then
            RemoveEsp(child, child.PrimaryPart)
        end
    end)

    charactersConnection = game.Workspace.Characters.ChildAdded:Connect(function(child)
        if child:IsA("Model") and child.PrimaryPart then
            if ActiveEspEnemy and
               not (child.Name == "Lost Child" or child.Name == "Lost Child2" or
                    child.Name == "Lost Child3" or child.Name == "Lost Child4" or
                    child.Name == "Pelt Trader") then
                CreateEsp(child, Color3.fromRGB(255, 0, 0), child.Name, child.PrimaryPart, 3)
            elseif ActiveEspChildren and
               (child.Name == "Lost Child" or child.Name == "Lost Child2" or
                child.Name == "Lost Child3" or child.Name == "Lost Child4") then
                CreateEsp(child, Color3.fromRGB(0, 255, 0), child.Name, child.PrimaryPart, 3)
            elseif ActiveEspPeltTrader and child.Name == "Pelt Trader" then
                CreateEsp(child, Color3.fromRGB(0, 255, 255), child.Name, child.PrimaryPart, 3)
            end
        end
    end)

    game.Workspace.Characters.ChildRemoved:Connect(function(child)
        if child:IsA("Model") and child.PrimaryPart then
            RemoveEsp(child, child.PrimaryPart)
        end
    end)
end

-- Initialize ESP connections
setupEspConnections()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

esptpTab:Button({
    Title = "Tp to campfire",
    Desc = "Teleports you to the campfire",
    Callback = function()
        local targetPosition = Vector3.new(0.2976149320602417, 6.346785545349121, -0.043002475053071976)
        
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
            
            WindUI:Notify({
                Title = "Teleport",
                Content = "Teleported successfully!",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "Teleport Failed",
                Content = "Somthing went wrong!",
                Duration = 1
            })
        end
    end
})

-- Item Teleporter with Auto-Detection Script
-- Scans workspace.Items and creates teleport system

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Configuration
local SCAN_INTERVAL = 1 -- Check every 1 second
local TELEPORT_OFFSET = Vector3.new(0, 5, 0) -- Teleport slightly above the item

-- Variables
local itemGroups = {}
local selectedItem = nil
local currentConnection = nil

-- WindUI Notification function (replace with your notification system)
local function notify(title, content, duration)
    -- Replace this with your actual notification system
    print("[" .. title .. "] " .. content)
    -- Example for WindUI:
    -- WindUI:Notify({
    --     Title = title,
    --     Content = content,
    --     Duration = duration or 3
    -- })
end

-- Function to get item position
local function getItemPosition(item)
    if item:IsA("BasePart") then
        return item.Position
    elseif item:IsA("Model") then
        local primaryPart = item.PrimaryPart
        if primaryPart then
            return primaryPart.Position
        else
            -- Find the first part in the model
            for _, child in pairs(item:GetChildren()) do
                if child:IsA("BasePart") then
                    return child.Position
                end
            end
        end
    end
    return nil
end

-- Function to teleport player
local function teleportToItem(item)
    if not item or not item.Parent then
        notify("Teleport Failed", "Item no longer exists!", 3)
        return false
    end
    
    local position = getItemPosition(item)
    if not position then
        notify("Teleport Failed", "Could not get item position!", 3)
        return false
    end
    
    -- Update character reference
    character = player.Character
    if not character then
        notify("Teleport Failed", "Character not found!", 3)
        return false
    end
    
    humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        notify("Teleport Failed", "HumanoidRootPart not found!", 3)
        return false
    end
    
    -- Teleport with offset
    local teleportPosition = position + TELEPORT_OFFSET
    humanoidRootPart.CFrame = CFrame.new(teleportPosition)
    
    notify("Teleported", "Teleported to " .. item.Name, 2)
    return true
end

-- Function to scan workspace.Items
local function scanItems()
    itemGroups = {}
    
    if not workspace:FindFirstChild("Items") then
        notify("Scan Error", "workspace.Items not found!", 3)
        return {}
    end
    
    local items = workspace.Items:GetChildren()
    local itemCounts = {}
    local itemInstances = {}
    
    -- Count items and store instances
    for _, item in pairs(items) do
        if item:IsA("BasePart") or item:IsA("Model") then
            local itemName = item.Name
            
            if not itemCounts[itemName] then
                itemCounts[itemName] = 0
                itemInstances[itemName] = {}
            end
            
            itemCounts[itemName] = itemCounts[itemName] + 1
            table.insert(itemInstances[itemName], item)
        end
    end
    
    -- Create dropdown options
    local dropdownValues = {}
    for itemName, count in pairs(itemCounts) do
        local displayName = itemName .. " (" .. count .. ")"
        table.insert(dropdownValues, displayName)
        itemGroups[displayName] = {
            name = itemName,
            count = count,
            instances = itemInstances[itemName]
        }
    end
    
    table.sort(dropdownValues) -- Sort alphabetically
    return dropdownValues
end

-- Function to find closest item of selected type
local function findClosestItem(itemName)
    if not itemGroups[itemName] or not itemGroups[itemName].instances then
        return nil
    end
    
    character = player.Character
    if not character then return nil end
    
    humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return nil end
    
    local playerPosition = humanoidRootPart.Position
    local closestItem = nil
    local closestDistance = math.huge
    
    -- Find closest valid item
    for _, item in pairs(itemGroups[itemName].instances) do
        if item and item.Parent then
            local itemPosition = getItemPosition(item)
            if itemPosition then
                local distance = (playerPosition - itemPosition).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestItem = item
                end
            end
        end
    end
    
    return closestItem
end

-- Function to start monitoring selected item
local function startMonitoring(itemName)
    if currentConnection then
        currentConnection:Disconnect()
    end
    
    currentConnection = RunService.Heartbeat:Connect(function()
        wait(SCAN_INTERVAL)
        
        if not itemGroups[itemName] then
            return
        end
        
        -- Update item instances (check if they still exist)
        local validInstances = {}
        local count = 0
        
        if workspace:FindFirstChild("Items") then
            for _, item in pairs(workspace.Items:GetChildren()) do
                if item.Name == itemGroups[itemName].name and (item:IsA("BasePart") or item:IsA("Model")) then
                    table.insert(validInstances, item)
                    count = count + 1
                end
            end
        end
        
        -- Update the group
        itemGroups[itemName].instances = validInstances
        itemGroups[itemName].count = count
        
        -- Notify if count changed significantly
        if count == 0 then
            notify("Items Gone", itemGroups[itemName].name .. " items no longer exist!", 3)
        end
    end)
end

-- Function to stop monitoring
local function stopMonitoring()
    if currentConnection then
        currentConnection:Disconnect()
        currentConnection = nil
    end
end

-- Initial scan
local initialItems = scanItems()

-- Create the dropdown and button (replace this with your actual UI system)
--[[
Tab:Dropdown({
    Title = "Select Item",
    Values = initialItems,
    Value = initialItems[1] or "No items found",
    Multi = false,
    AllowNone = false,
    Callback = function(selected)
        print("Selected item group:", selected)
        selectedItem = selected
        
        if selected and itemGroups[selected] then
            notify("Item Selected", "Selected: " .. itemGroups[selected].name .. " (" .. itemGroups[selected].count .. " available)", 2)
            startMonitoring(selected)
        else
            stopMonitoring()
        end
    end
})

Tab:Button({
    Title = "Teleport to Item",
    Desc = "Teleport to the closest selected item",
    Callback = function()
        if not selectedItem then
            notify("No Selection", "Please select an item first!", 3)
            return
        end
        
        if not itemGroups[selectedItem] then
            notify("Invalid Selection", "Selected item group no longer exists!", 3)
            return
        end
        
        local closestItem = findClosestItem(selectedItem)
        if closestItem then
            local success = teleportToItem(closestItem)
            if success then
                notify("Success", "Teleported to closest " .. itemGroups[selectedItem].name, 2)
            end
        else
            notify("Not Found", "No " .. itemGroups[selectedItem].name .. " items available!", 3)
        end
    end
})

Tab:Button({
    Title = "Refresh Items",
    Desc = "Rescan workspace.Items for new items",
    Callback = function()
        local newItems = scanItems()
        notify("Refreshed", "Found " .. #newItems .. " different item types", 2)
        
        -- You would need to update your dropdown here with newItems
        -- This depends on your UI framework
        print("Available items after refresh:")
        for i, item in pairs(newItems) do
            print(i .. ". " .. item)
        end
    end
})
]]

-- Console version for testing (remove when integrating with UI)
print("=== ITEM TELEPORTER LOADED ===")
print("Available item groups:")
for i, item in pairs(initialItems) do
    print(i .. ". " .. item)
end

-- Example usage functions (for testing without UI)
local function selectItemByIndex(index)
    if initialItems[index] then
        selectedItem = initialItems[index]
        print("Selected:", selectedItem)
        startMonitoring(selectedItem)
        return true
    end
    return false
end

local function teleportToSelected()
    if not selectedItem then
        print("No item selected!")
        return
    end
    
    local closestItem = findClosestItem(selectedItem)
    if closestItem then
        teleportToItem(closestItem)
    else
        print("No items of type '" .. itemGroups[selectedItem].name .. "' found!")
    end
end

-- Expose functions for console use
_G.ItemTeleporter = {
    scanItems = scanItems,
    selectItem = selectItemByIndex,
    teleport = teleportToSelected,
    refresh = function()
        initialItems = scanItems()
        print("Refreshed! Available items:")
        for i, item in pairs(initialItems) do
            print(i .. ". " .. item)
        end
    end,
    stopMonitoring = stopMonitoring
}

print("\nConsole commands:")
print("_G.ItemTeleporter.refresh() - Refresh item list")
print("_G.ItemTeleporter.selectItem(index) - Select item by number")
print("_G.ItemTeleporter.teleport() - Teleport to selected item")
print("_G.ItemTeleporter.stopMonitoring() - Stop monitoring")

-- Auto-refresh every 30 seconds
spawn(function()
    while true do
        wait(3)
        scanItems()
    end
end)

-- Clean up on character respawn
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
end)

-- Window close callback
Window:OnClose(function()
    print("Window closed.")
end)
