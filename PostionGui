local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

WindUI:SetNotificationLower(true)

-- Add Custom Blue Theme
WindUI:AddTheme({
    Name = "Blue Theme",
    Accent = Color3.fromRGB(37, 99, 235),
    Dialog = Color3.fromRGB(15, 23, 42),
    Outline = Color3.fromRGB(59, 130, 246),
    Text = Color3.fromRGB(248, 250, 252),
    Placeholder = Color3.fromRGB(100, 116, 139),
    Background = Color3.fromRGB(15, 23, 42),
    Button = Color3.fromRGB(30, 58, 138),
    Icon = Color3.fromRGB(147, 197, 253)
})

local Window = WindUI:CreateWindow({
    Title = "Fryzer Hub",
    Author = "Join Discord",
    Folder = "FryzerHub",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Blue Theme",
    Resizable = true,
    SideBarWidth = 200,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = false,
    ScrollBarEnabled = true,
})

Window:Tag({
    Title = "v1.3.6",
    Color = Color3.fromHex("#30ff6a"),
    Radius = 8,
})

Window:Tag({
    Title = "Fish It",
    Color = Color3.fromHex("#ff0000"),
    Radius = 10,
})

local InfoTab = Window:Tab({
    Title = "Info",
    Icon = "info",
    Locked = false,
})

InfoTab:Select()

-- ==================== PLAYER INFORMATION SECTION ====================
local Sectiontest = InfoTab:Section({
    Title = "Player Information Dashboard",
    Icon = "user-check",
})

InfoTab:Paragraph({
    Title = "Player Information Dashboard",
    Desc = "Complete player details, game information, and community access",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Player = Players.LocalPlayer
local PlayerName = Player.DisplayName ~= "" and Player.DisplayName or Player.Name
local AccountAge = Player.AccountAge
local GameName = "Unknown Game"
pcall(function()
    GameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
end)

InfoTab:Paragraph({
    Title = "üë§ " .. PlayerName,
    Desc = string.format(
        "üè∑Ô∏è Username: @%s\nüéÇ Account Age: %d days\nüÜî User ID: %d\nüéÆ Current Game: %s\nüë• Server: %d/%d players\nüìç Region: %s",
        Player.Name, AccountAge, Player.UserId, GameName,
        #Players:GetPlayers(), Players.MaxPlayers,
        game:GetService("LocalizationService").RobloxLocaleId
    ),
    Color = "Blue",
    Image = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. Player.UserId .. "&width=150&height=150&format=png",
    ImageSize = 52,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

InfoTab:Divider()

-- ==================== DISCORD COMMUNITY SECTION ====================
local DiscordSection = InfoTab:Section({
    Title = "Join Our Discord Community",
    Icon = "users",
})

InfoTab:Paragraph({
    Title = "üéÆ Connect & Engage",
    Desc = "Join thousands of players in our Discord community for updates, support, and exclusive content!",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

-- Discord API Configuration
local InviteCode = "UKYHGddQD3"
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

-- Universal HTTP Request Handler
local function HttpRequest(data)
    if syn and syn.request then
        return syn.request(data)
    elseif http and http.request then
        return http.request(data)
    elseif http_request then
        return http_request(data)
    elseif request then
        return request(data)
    else
        error("Your executor does not support HTTP requests.")
    end
end

local DiscordResponse
local DiscordErrorMessage = nil
local DiscordInfoParagraph

-- Fetch Discord Information
xpcall(function()
    local req = HttpRequest({
        Url = DiscordAPI,
        Method = "GET",
        Headers = {
            ["Accept"] = "application/json"
        }
    })

    if req and req.Body then
        DiscordResponse = HttpService:JSONDecode(req.Body)
    else
        error("Invalid response from Discord API.")
    end
end, function(err)
    warn("Error fetching Discord info: " .. tostring(err))
    DiscordErrorMessage = tostring(err)
    DiscordResponse = nil
end)

-- Display Discord Information
if DiscordResponse and DiscordResponse.guild then
    local guildName = DiscordResponse.guild.name or "Unknown Server"
    local memberCount = DiscordResponse.approximate_member_count or 0
    local onlineCount = DiscordResponse.approximate_presence_count or 0
    
    local ParagraphConfig = {
        Title = "üî∑ " .. guildName,
        Desc = 
            'üìä <font color="#3b82f6"><b>Members:</b></font> ' .. tostring(memberCount) ..
            '\nüü¢ <font color="#10b981"><b>Online:</b></font> ' .. tostring(onlineCount) ..
            '\nüìà <font color="#f59e0b"><b>Activity:</b></font> ' .. math.floor((onlineCount / math.max(memberCount, 1)) * 100) .. '% active',
        Color = "Red",
        ImageSize = 52,
        Buttons = {
            {
                Icon = "link",
                Title = "Copy Invite",
                Callback = function()
                    pcall(function()
                        setclipboard("https://discord.gg/" .. InviteCode)
                        WindUI:Notify({
                            Title = "‚úÖ Copied!",
                            Content = "Discord invite copied to clipboard.",
                            Duration = 3,
                            Icon = "copy",
                        })
                    end)
                end
            },
            {
                Icon = "refresh-cw",
                Title = "Update Stats",
                Callback = function()
                    xpcall(function()
                        local upd = HttpRequest({
                            Url = DiscordAPI,
                            Method = "GET",
                            Headers = {
                                ["Accept"] = "application/json"
                            }
                        })
                        if upd and upd.Body then
                            local UpdatedResponse = HttpService:JSONDecode(upd.Body)
                            if UpdatedResponse and UpdatedResponse.guild then
                                local newMembers = UpdatedResponse.approximate_member_count or 0
                                local newOnline = UpdatedResponse.approximate_presence_count or 0
                                local activity = math.floor((newOnline / math.max(newMembers, 1)) * 100)
                                
                                DiscordInfoParagraph:SetDesc(
                                    'üìä <font color="#3b82f6"><b>Members:</b></font> ' .. tostring(newMembers) ..
                                    '\nüü¢ <font color="#10b981"><b>Online:</b></font> ' .. tostring(newOnline) ..
                                    '\nüìà <font color="#f59e0b"><b>Activity:</b></font> ' .. activity .. '% active'
                                )
                                WindUI:Notify({
                                    Title = "üîÑ Updated!",
                                    Content = "Discord stats refreshed successfully.",
                                    Duration = 2,
                                    Icon = "check",
                                })
                            end
                        end
                    end, function(err)
                        warn("Error updating Discord info: " .. tostring(err))
                        WindUI:Notify({
                            Title = "‚ö†Ô∏è Update Failed",
                            Content = "Could not refresh Discord stats.",
                            Duration = 3,
                            Icon = "alert-circle",
                        })
                    end)
                end
            }
        }
    }

    -- Add guild icon if available
    if DiscordResponse.guild.icon then
        ParagraphConfig.Image = "https://cdn.discordapp.com/icons/" .. DiscordResponse.guild.id .. "/" .. DiscordResponse.guild.icon .. ".png?size=256"
    end

    -- Add banner if available
    if DiscordResponse.guild.banner then
        ParagraphConfig.Thumbnail = "https://cdn.discordapp.com/banners/" .. DiscordResponse.guild.id .. "/" .. DiscordResponse.guild.banner .. ".png?size=512"
        ParagraphConfig.ThumbnailSize = 80
    end

    DiscordInfoParagraph = InfoTab:Paragraph(ParagraphConfig)
else
    InfoTab:Paragraph({
        Title = "‚ö†Ô∏è Discord Info Unavailable",
        Desc = DiscordErrorMessage or "Unable to fetch Discord server information. Try again later!",
        Color = "Blue",
        ImageSize = 26,
    })
end

-- Quick Action Button
InfoTab:Button({
    Title = "üìã Copy Discord Link",
    Desc = "Copy invite link to clipboard",
    Locked = false,
    Callback = function()
        setclipboard("https://discord.gg/" .. InviteCode)
        WindUI:Notify({
            Title = "‚úÖ Link Copied!",
            Content = "Discord invite copied to clipboard",
            Duration = 3,
            Icon = "copy",
        })
    end
})

InfoTab:Space()

-- ==================== TAB 2: PLAYER ====================
local PlayerTab = Window:Tab({
    Title = "Player",
    Icon = "user-check",
    Locked = false,
})

local Section3 = PlayerTab:Section({
    Title = "Player Controls",
    Icon = "user-check",
})

PlayerTab:Paragraph({
    Title = "Player Controls",
    Desc = "Use the buttons below to control your player character",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

PlayerTab:Divider()

local Section4 = PlayerTab:Section({
    Title = "Movement System",
    Icon = "zap",
    Opened = true,
})

-- Infinite Jump Toggle
local infiniteJumpEnabled = false
local UserInputService = game:GetService("UserInputService")

PlayerTab:Toggle({
    Title = "Infinite Jump",
    Desc = "Press Space to jump infinitely",
    Icon = "arrow-up",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        infiniteJumpEnabled = state
        WindUI:Notify({
            Title = state and "Infinite Jump Enabled! üöÄ" or "Infinite Jump Disabled!",
            Content = state and "Press Space to jump infinitely" or "Jump mechanics restored to normal",
            Duration = 3,
        })
    end
})

UserInputService.JumpRequest:Connect(function()
    if infiniteJumpEnabled and Player.Character and Player.Character:FindFirstChild("Humanoid") then
        local humanoid = Player.Character.Humanoid
        if humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local ActiveSpeedBoost = false
local ActiveJumpBoost = false
local ActiveNoclip = false
local ActiveInstantPrompts = false
local ValueSpeed = 16
local ValueJumpHeight = 7.2
local OldSpeed = 16
local OldJumpHeight = 7.2

local function getCharacter()
    return LocalPlayer.Character
end

local function getHumanoid()
    local character = getCharacter()
    return character and character:FindFirstChildOfClass("Humanoid")
end

local function updateOriginalValues()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        OldSpeed = LocalPlayer.Character.Humanoid.WalkSpeed
        OldJumpHeight = LocalPlayer.Character.Humanoid.JumpHeight or 7.2
    end
end

updateOriginalValues()
LocalPlayer.CharacterAdded:Connect(updateOriginalValues)



PlayerTab:Divider()

-- Speed Controls
PlayerTab:Slider({
    Title = "Walk Speed Setting",
    Step = 1,
    Value = {
        Min = 16,
        Max = 500,
        Default = 16,
    },
    Callback = function(value)
        ValueSpeed = value
        print("üèÉ Walk speed set to: " .. value)
    end
})

PlayerTab:Toggle({
    Title = "Enable Speed Boost",
    Desc = "Boost your walking speed",
    Icon = "zap",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        ActiveSpeedBoost = state
        
        task.spawn(function()
            while ActiveSpeedBoost do
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    LocalPlayer.Character.Humanoid.WalkSpeed = ValueSpeed
                end
                task.wait(0.1)
            end
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = OldSpeed
            end
        end)
        
        print("üèÉ Speed Boost: " .. (state and "ON" or "OFF"))
    end
})

PlayerTab:Divider()

-- Jump Controls
PlayerTab:Slider({
    Title = "Jump Height Setting",
    Step = 1,
    Value = {
        Min = 7,
        Max = 200,
        Default = 50,
    },
    Callback = function(value)
        ValueJumpHeight = value
        print("ü¶ò Jump height set to: " .. value)
    end
})

PlayerTab:Toggle({
    Title = "Enable Jump Boost",
    Desc = "Increase your jump height",
    Icon = "move-up",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        ActiveJumpBoost = state
        
        task.spawn(function()
            while ActiveJumpBoost do
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    local humanoid = LocalPlayer.Character.Humanoid
                    humanoid.UseJumpPower = false
                    humanoid.JumpHeight = ValueJumpHeight
                end
                task.wait(0.1)
            end
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                local humanoid = LocalPlayer.Character.Humanoid
                humanoid.JumpHeight = 7.2
            end
        end)
        
        print("ü¶ò Jump Boost: " .. (state and "ON" or "OFF"))
    end
})

PlayerTab:Divider()

PlayerTab:Space()

-- Fly System
local IYMouse = Players.LocalPlayer:GetMouse()
local FLYING = false
local QEfly = true
local iyflyspeed = 1
local vehicleflyspeed = 1
local ActivateFly = false

local function sFLY(vfly)
    repeat task.wait() until Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart") and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    repeat task.wait() until IYMouse
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end

    local T = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0

    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro')
        local BV = Instance.new('BodyVelocity')
        BG.P = 9e4
        BG.Parent = T
        BV.Parent = T
        BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.CFrame = T.CFrame
        BV.Velocity = Vector3.new(0, 0, 0)
        BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            repeat task.wait()
                if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                    Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = 50
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.Velocity = Vector3.new(0, 0, 0)
                end
                BG.CFrame = workspace.CurrentCamera.CoordinateFrame
            until not FLYING
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:Destroy()
            BV:Destroy()
            if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
            end
        end)
    end
    flyKeyDown = IYMouse.KeyDown:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 's' then
            CONTROL.B = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'a' then
            CONTROL.L = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'd' then 
            CONTROL.R = (vfly and vehicleflyspeed or iyflyspeed)
        elseif QEfly and KEY:lower() == 'e' then
            CONTROL.Q = (vfly and vehicleflyspeed or iyflyspeed)*2
        elseif QEfly and KEY:lower() == 'q' then
            CONTROL.E = -(vfly and vehicleflyspeed or iyflyspeed)*2
        end
        pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
    end)
    flyKeyUp = IYMouse.KeyUp:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = 0
        elseif KEY:lower() == 's' then
            CONTROL.B = 0
        elseif KEY:lower() == 'a' then
            CONTROL.L = 0
        elseif KEY:lower() == 'd' then
            CONTROL.R = 0
        elseif KEY:lower() == 'e' then
            CONTROL.Q = 0
        elseif KEY:lower() == 'q' then
            CONTROL.E = 0
        end
    end)
    FLY()
end

local function NOFLY()
    FLYING = false
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end
    if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
        Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
    end
    pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

-- Mobile Fly
local velocityHandlerName = "BodyVelocity"
local gyroHandlerName = "BodyGyro"
local mfly1
local mfly2

local function UnMobileFly()
    pcall(function()
        FLYING = false
        local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        root:FindFirstChild(velocityHandlerName):Destroy()
        root:FindFirstChild(gyroHandlerName):Destroy()
        Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
        mfly1:Disconnect()
        mfly2:Disconnect()
    end)
end

local function MobileFly()
    UnMobileFly()
    FLYING = true

    local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local camera = workspace.CurrentCamera
    local v3none = Vector3.new()
    local v3zero = Vector3.new(0, 0, 0)
    local v3inf = Vector3.new(9e9, 9e9, 9e9)

    local controlModule = require(Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    local bv = Instance.new("BodyVelocity")
    bv.Name = velocityHandlerName
    bv.Parent = root
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = gyroHandlerName
    bg.Parent = root
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50

    mfly1 = Players.LocalPlayer.CharacterAdded:Connect(function()
        local bv = Instance.new("BodyVelocity")
        bv.Name = velocityHandlerName
        bv.Parent = root
        bv.MaxForce = v3zero
        bv.Velocity = v3zero

        local bg = Instance.new("BodyGyro")
        bg.Name = gyroHandlerName
        bg.Parent = root
        bg.MaxTorque = v3inf
        bg.P = 1000
        bg.D = 50
    end)

    mfly2 = RunService.RenderStepped:Connect(function()
        root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        camera = workspace.CurrentCamera
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
            local humanoid = Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
            local VelocityHandler = root:FindFirstChild(velocityHandlerName)
            local GyroHandler = root:FindFirstChild(gyroHandlerName)

            VelocityHandler.MaxForce = v3inf
            GyroHandler.MaxTorque = v3inf
            humanoid.PlatformStand = true
            GyroHandler.CFrame = camera.CoordinateFrame
            VelocityHandler.Velocity = v3none

            local direction = controlModule:GetMoveVector()
            if direction.X > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.X < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((iyflyspeed) * 50))
            end
            if direction.Z > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
            if direction.Z < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((iyflyspeed) * 50))
            end
        end
    end)
end

PlayerTab:Slider({
    Title = "Fly Speed",
    Step = 0.1,
    Value = {
        Min = 0.1,
        Max = 10,
        Default = 1
    },
    Callback = function(val)
        iyflyspeed = val
    end
})

PlayerTab:Toggle({
    Title = "Fly",
    Desc = "Enable flying with WASD controls",
    Icon = "plane",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        ActivateFly = state
        task.spawn(function()
            if not FLYING and ActivateFly then
                if UserInputService.TouchEnabled then
                    MobileFly()
                else
                    NOFLY()
                    task.wait()
                    sFLY()
                end
            elseif FLYING and not ActivateFly then
                if UserInputService.TouchEnabled then
                    UnMobileFly()
                else
                    NOFLY()
                end
            end
        end)
    end
})

PlayerTab:Space()

-- Main Tab
-- ==================== TAB 2: MAIN ====================
local MainTab = Window:Tab({
    Title = "Main",
    Icon = "house",
    Locked = false,
})


-- ====================================================================
--                     BRAINROT AUTO COLLECT TOGGLE
-- ====================================================================

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Configuration
local Config = {
    AutoCollect = false
}

-- Variables
local character = nil
local humanoidRootPart = nil
local brainrotsFolder = nil
local collectLoop = nil

-- Initialize
local function initialize()
    character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    brainrotsFolder = workspace:WaitForChild("Brainrots")
end

-- Safe initialization
pcall(initialize)

-- Auto Collect Function
local function startAutoCollect()
    if collectLoop then return end
    
    collectLoop = task.spawn(function()
        while Config.AutoCollect do
            if not humanoidRootPart or not humanoidRootPart.Parent then
                -- Character respawned, reinitialize
                pcall(initialize)
                task.wait(1)
                continue
            end
            
            local positions = {}
            
            -- Collect all brainrots
            pcall(function()
                for _, v in ipairs(brainrotsFolder:GetChildren()) do
                    if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") then
                        positions[v] = v.HumanoidRootPart.CFrame
                        v.HumanoidRootPart.CFrame = humanoidRootPart.CFrame
                    elseif v:IsA("BasePart") then
                        positions[v] = v.CFrame
                        v.CFrame = humanoidRootPart.CFrame
                    end
                end
            end)
            
            -- Wait for collection
            task.wait(1)
            
            -- Restore positions
            pcall(function()
                for v, originalCFrame in pairs(positions) do
                    if v and v.Parent then
                        if v:IsA("Model") and v:FindFirstChild("HumanoidRootPart") then
                            v.HumanoidRootPart.CFrame = originalCFrame
                        elseif v:IsA("BasePart") then
                            v.CFrame = originalCFrame
                        end
                    end
                end
            end)
            
            -- Wait before next cycle
            task.wait(3)
        end
        
        collectLoop = nil
    end)
end

local function stopAutoCollect()
    Config.AutoCollect = false
    if collectLoop then
        task.cancel(collectLoop)
        collectLoop = nil
    end
end

-- Handle character respawn
LocalPlayer.CharacterAdded:Connect(function(newChar)
    character = newChar
    humanoidRootPart = newChar:WaitForChild("HumanoidRootPart")
    
    -- Restart auto collect if it was enabled
    if Config.AutoCollect then
        task.wait(1)
        startAutoCollect()
    end
end)

-- ====================================================================
--                     WIND UI TOGGLE
-- ====================================================================

-- Section: Auto Collect
local Section1 = MainTab:Section({
    Title = "Brainrot Auto Collect",
    Icon = "zap",
})

-- AUTO COLLECT TOGGLE
local AutoCollectToggle = MainTab:Toggle({
    Title = "üß† Auto Collect Brainrots",
    Desc = "Automatically teleports and collects brainrots",
    Icon = "magnet",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        Config.AutoCollect = state
        
        if state then
            print("[Auto Collect] üü¢ Started collecting brainrots")
            startAutoCollect()
        else
            print("[Auto Collect] üî¥ Stopped collecting brainrots")
            stopAutoCollect()
        end
    end
})

print("[Auto Collect] ‚úÖ Brainrot collector loaded!")

-- ==================== TAB 4: MISC ====================
local MiscTab = Window:Tab({
    Title = "Misc",
    Icon = "folder",
    Locked = false,
})

local ToggleAntiAFK = MiscTab:Toggle({
    Title = "Anti AFK",
    Desc = "Prevents automatic idle kick",
    Icon = "shield-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if state then
            local player = game.Players.LocalPlayer

            -- Disconnect existing idle connections if any
            if getgenv().AntiAFKConnection then
                getgenv().AntiAFKConnection:Disconnect()
            end

            -- Connect to Idled event
            getgenv().AntiAFKConnection = player.Idled:Connect(function()
                -- simulate click or jump to prevent kick
                game:GetService("VirtualUser"):CaptureController()
                game:GetService("VirtualUser"):ClickButton2(Vector2.new())
                print("‚è± Anti-AFK triggered!")
            end)

            print("‚úÖ Anti-AFK enabled")
        else
            -- Disconnect Anti-AFK
            if getgenv().AntiAFKConnection then
                getgenv().AntiAFKConnection:Disconnect()
                getgenv().AntiAFKConnection = nil
            end
            print("‚õî Anti-AFK disabled")
        end
    end
})

local Buttonpowersave = MiscTab:Button({
    Title = "Power Save Mode",
    Desc = "Open Power Save Script",
    Locked = false,
    Callback = function()
        print("Opening Power Save Script...")
        loadstring(game:HttpGet("https://raw.githubusercontent.com/FryzerHub/SubScripts/refs/heads/main/screen%20saver"))()
    end
})

-- ==================== TAB 6: SETTINGS ====================
local Tab6 = Window:Tab({
    Title = "Settings",
    Icon = "settings",
    Locked = false,
})

local SettingsSection1 = Tab6:Section({
    Title = "Window Settings",
    Icon = "layout",
})

Tab6:Space()

local TransparencyToggle = Tab6:Toggle({
    Title = "Window Transparency",
    Desc = "Toggle window transparency on/off",
    Icon = "eye",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        Window:ToggleTransparency(state)
        print("Transparency: " .. tostring(state))
    end
})

Tab6:Divider()

local SettingsSection2 = Tab6:Section({
    Title = "Keybind Settings",
    Icon = "keyboard",
})

local KeybindInput = Tab6:Input({
    Title = "Toggle UI Keybind",
    Desc = "Type ONE letter or key (e.g., Q or RightControl)",
    Value = "RightControl",
    InputIcon = "keyboard",
    Type = "Input",
    Placeholder = "Enter key...",
    Callback = function(input)
        input = input:gsub("^%s*(.-)%s*$", "%1")
        
        local keyCode
        
        if #input == 1 then
            local upperInput = input:upper()
            keyCode = Enum.KeyCode[upperInput]
        else
            local success, result = pcall(function()
                return Enum.KeyCode[input]
            end)
            if success then
                keyCode = result
            end
        end
        
        if keyCode then
            Window:SetToggleKey(keyCode)
            print("Keybind set to: " .. input)
            WindUI:Notify({
                Title = "Keybind Updated",
                Content = "Press '" .. input .. "' to toggle UI",
                Duration = 3,
                Icon = "check",
            })
        else
            print("Invalid key: " .. input)
            WindUI:Notify({
                Title = "Invalid Key",
                Content = "Enter a single letter (Q) or key name (RightControl)",
                Duration = 4,
                Icon = "x",
            })
        end
    end
})

Window:SetToggleKey(Enum.KeyCode.RightControl)

Tab6:Space()
